ย
'D:\home\projects\ps-dotenv\Parsing\A.cs
	namespace 	
System
 
. 
Runtime 
. 
CompilerServices )
;) *
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
internal 
static	 
class 
IsExternalInit $
{% &
}' (
+D:\home\projects\ps-dotenv\Parsing\Entry.cs
	namespace 	
Dotenv
 
. 
Parsing 
; 
public 
readonly 
struct 
Entry 
{ 
public 
readonly 
string 
Name 
{ 
get "
;" #
init$ (
;( )
}* +
internal 	
readonly
 
Value 
val 
{ 
get "
;" #
init$ (
;( )
}* +
internal 	
Entry
 
( 
string 
name 
, 
Value "
val# &
)& '
=>( *
(+ ,
this, 0
.0 1
Name1 5
,5 6
this7 ;
.; <
val< ?
)? @
=A B
(C D
nameD H
,H I
valJ M
)M N
;N O
public		 
string		 
ExpandValue		 
(		 
)		 
=>		 
this		  $
.		$ %
val		% (
.		( )
ExpandValue		) 4
(		4 5
)		5 6
;		6 7
public

 
void

 
SetEnv

 
(

 
)

 
=>

 
System

 
.

  
Environment

  +
.

+ ,"
SetEnvironmentVariable

, B
(

B C
this

C G
.

G H
Name

H L
,

L M
this

N R
.

R S
ExpandValue

S ^
(

^ _
)

_ `
)

` a
;

a b
} ๖+
,D:\home\projects\ps-dotenv\Parsing\Errors.cs
	namespace 	
Dotenv
 
. 
Parsing 
; 
public 
abstract 
class 

ParseError  
:  !
	Exception" +
{, -
public 
int 
Line 
{ 
get 
; 
set 
; 
} 
public 

ParseError 
( 
int 
line 
, 
string #
msg$ '
)' (
: 
base 
( 
$" 

$str
 
{ 
line 
} 
$str 
{ 
msg 
} 
" 
) 
{  
Line 
= 
line	 
; 
}		 
public 
override 
string 
ToString  
(  !
)! "
=># %
this& *
.* +
Message+ 2
;2 3
} 
public 
class 
ErrInvalidName 
: 

ParseError '
{( )
public 
ErrInvalidName 
( 
int 
line 
)  
: 
base 
( 
line 
, 
$str M
)M N
{O P
}Q R
public 
ErrInvalidName 
( 
int 
line 
,  
string! '
msg( +
)+ ,
: 
base 
( 
line 
, 
msg 
) 
{ 
} 
} 
public 
class 
ErrMissingEquals 
: 

ParseError )
{* +
public 
ErrMissingEquals 
( 
int 
line !
)! "
: 
base 
( 
line 
, 
$str  
)  !
{" #
}$ %
} 
public 
class 
ErrUnclosedQuote 
: 

ParseError )
{* +
public 
ErrUnclosedQuote 
( 
int 
line !
)! "
: 
base 
( 
line 
, 
$str 
) 
{  !
}" #
} 
public   
class   
AssertionException   
:    
	Exception  ! *
{  + ,
public!! 
AssertionException!! 
(!! 
string!! !
msg!!" %
)!!% &
:"" 
base"" 
("" 
$""" 

$str""
  
{""  !
msg""! $
}""$ %
"""% &
)""& '
{""( )
}""* +
}## 
public%% 
class%% 
ErrMissingNewline%% 
:%% 

ParseError%%  *
{%%+ ,
public&& 
ErrMissingNewline&& 
(&& 
int&& 
line&& "
)&&" #
:'' 
base'' 
('' 
line'' 
,'' 
$str'' H
)''H I
{''J K
}''L M
}(( 
public** 
class** 
ErrMissingRBrace** 
:** 

ParseError** )
{*** +
public++ 
ErrMissingRBrace++ 
(++ 
int++ 
line++ !
)++! "
:,, 
base,, 
(,, 
line,, 
,,, 
$str,, H
),,H I
{,,J K
},,L M
}-- 
public// 
class// 
VarUnsetException// 
:// 
	Exception//  )
{//* +
public00 
string00 
VariableName00 
{00 
get00 !
;00! "
private00# *
set00+ .
;00. /
}000 1
public11 
string11 
?11 
Msg11 
{11 
get11 
;11 
private11 "
set11# &
;11& '
}11( )
public33 
VarUnsetException33 
(33 
string33  
name33! %
,33% &
string33' -
?33- .
msg33/ 2
)332 3
:44 
base44 
(44 
$"44 

{44
 
name44 
}44 
$str44 
{44 
msg44 
??44 
$str44 0
}440 1
"441 2
)442 3
{444 5
this55 
.55 
VariableName55 
=55 
name55 
;55 
this66 
.66 
Msg66 

=66 
msg66 
??66 
$str66 -
;66- .
}77 
public99 
override99 
string99 
ToString99  
(99  !
)99! "
=>99# %
base99& *
.99* +
Message99+ 2
;992 3
}:: 
public<< 
class<< 
ErrBadSubstitution<< 
:<<  

ParseError<<! +
{<<, -
public== 
ErrBadSubstitution== 
(== 
int== 
line== #
)==# $
:==% &
base==' +
(==+ ,
line==, 0
,==0 1
$str==2 D
)==D E
{==F G
}==H I
}>> ลื
,D:\home\projects\ps-dotenv\Parsing\Parser.cs
	namespace 	
Dotenv
 
. 
Parsing 
; 
public 
class 
Parser 
: 
IEnumerable  
<  !
Result! '
<' (
Entry( -
>- .
>. /
{0 1
public 
Parser 
( 
string 
input 
) 
{ 
this 
. 
input 
= 
input 
. 
Replace 
( 
$str #
,# $
$str% )
)) *
;* +
this		 
.		 
ch		 	
=		
 
this		 
.		 
input		 
.		 
Length		 
>		 
$num		  !
?		" #
this		$ (
.		( )
input		) .
[		. /
$num		/ 0
]		0 1
:		2 3
EOF		4 7
;		7 8
}

 
private 
const	 
char 
EOF 
= 
char 
. 
MinValue '
;' (
private 
string	 
input 
; 
private 
int	 
line 
= 
$num 
; 
private 
int	 
pos 
= 
$num 
; 
private 
char	 
ch 
; 
private 
int	 
readpos 
=> 
this 
. 
pos  
+! "
$num# $
;$ %
private 
char	 
peek 
=> 
this 
. 
readpos "
<# $
this% )
.) *
input* /
./ 0
Length0 6
?7 8
this9 =
.= >
input> C
[C D
thisD H
.H I
readposI P
]P Q
:R S
EOFT W
;W X
private 
void	 
read 
( 
) 
{ 
this 
. 
pos 

++
 
; 
if 
( 
this 

.
 
pos 
>= 
this 
. 
input 
. 
Length #
)# $
{% &
this 
. 
ch 

= 
EOF 
; 
} 
else 
{	 

this 
. 
ch 

= 
this 
. 
input 
[ 
this 
. 
pos  
]  !
;! "
if 
( 
this 
. 
ch 
== 
$char 
) 
this 
. 
line !
++! #
;# $
} 
} 
private   
static  	 
char   
escaped   
(   
char   !
c  " #
)  # $
=>  % '
c  ( )
switch  * 0
{  1 2
$char!! 
=>!! 
$char!!	 
,!! 
$char"" 
=>"" 
$char""	 
,"" 
$char## 
=>## 
$char##	 
,## 
$char$$ 
=>$$ 
$char$$	 
,$$ 
$char%% 
=>%% 
$char%%	 
,%% 
$char&& 
=>&& 
$char&&	 
,&& 
_'' 
=>'' 
c'' 
,'' 	
}(( 
;(( 
private** 
static**	 
bool** 
	isSpecial** 
(** 
char** #
c**$ %
)**% &
=>**' )
c*** +
switch**, 2
{**3 4
$char++ 
or++ 
$char++	 
or++ 
$char++ 
or++ 
$char++ 
=>++ 
true++  $
,++$ %
_,, 
=>,, 
false,, 
,,, 
}-- 
;-- 
private// 
void//	 
skipLine// 
(// 
)// 
=>// 
this//  
.//  !
	skipWhile//! *
(//* +
c//+ ,
=>//- /
c//0 1
!=//2 4
EOF//5 8
&&//9 ;
c//< =
!=//> @
$char//A E
)//E F
;//F G
private00 
void00	 
	skipSpace00 
(00 
)00 
=>00 
this00 !
.00! "
	skipWhile00" +
(00+ ,
c00, -
=>00. 0
c001 2
!=003 5
$char006 :
&&00; =
char00> B
.00B C
IsWhiteSpace00C O
(00O P
c00P Q
)00Q R
)00R S
;00S T
private11 
void11	 
	skipWhile11 
(11 
Func11 
<11 
char11 !
,11! "
bool11# '
>11' (
fn11) +
)11+ ,
{11- .
while22 
(22 	
this22	 
.22 
ch22 
!=22 
EOF22 
&&22 
fn22 
(22 
this22 "
.22" #
ch22# %
)22% &
)22& '
this22( ,
.22, -
read22- 1
(221 2
)222 3
;223 4
}33 
private55 
string55	 
	readWhile55 
(55 
Func55 
<55 
char55 #
,55# $
bool55% )
>55) *
fn55+ -
)55- .
{55/ 0
var66 
start66 
=66 
this66 
.66 
pos66 
;66 
while77 
(77 	
this77	 
.77 
ch77 
!=77 
EOF77 
&&77 
fn77 
(77 
this77 "
.77" #
ch77# %
)77% &
)77& '
this77( ,
.77, -
read77- 1
(771 2
)772 3
;773 4
return88 
this88	 
.88 
input88 
.88 
	Substring88 
(88 
start88 #
,88# $
this88% )
.88) *
pos88* -
-88. /
start880 5
)885 6
;886 7
}99 
private;; 
bool;;	 
aheadIs;; 
(;; 
string;; 
s;; 
);; 
=>;;  "
this;;# '
.;;' (
input;;( -
.;;- .
	Substring;;. 7
(;;7 8
this;;8 <
.;;< =
pos;;= @
);;@ A
.;;A B

StartsWith;;B L
(;;L M
s;;M N
,;;N O
StringComparison;;P `
.;;` a
Ordinal;;a h
);;h i
;;;i j
private== 
void==	 
expect== 
(== 
char== 
c== 
)== 
{== 
if>> 
(>> 
this>> 

.>>
 
ch>> 
!=>> 
c>> 
)>> 
throw>> 
new>> 
AssertionException>> 0
(>>0 1
$">>1 3
$str>>3 :
{>>: ;
c>>; <
}>>< =
$str>>= >
">>> ?
)>>? @
;>>@ A
this?? 
.?? 
read?? 
(?? 
)?? 
;?? 
}@@ 
privateBB 
voidBB	 
expectBB 
(BB 
stringBB 
sBB 
)BB 
{BB  
ifCC 
(CC 
!CC 
thisCC 
.CC 

tryConsumeCC 
(CC 
sCC 
)CC 
)CC 
throwCC  
newCC! $
AssertionExceptionCC% 7
(CC7 8
$"CC8 :
$strCC: A
{CCA B
sCCB C
}CCC D
$strCCD E
"CCE F
)CCF G
;CCG H
}DD 
privateFF 
boolFF	 

tryConsumeFF 
(FF 
stringFF 
firstFF  %
,FF% &
paramsFF' -
stringFF. 4
[FF4 5
]FF5 6
restFF7 ;
)FF; <
{FF= >
ifGG 
(GG 
thisGG 

.GG
 
aheadIsGG 
(GG 
firstGG 
)GG 
)GG 
{GG 
forHH 
(HH 
intHH 
iHH 
=HH 
$numHH 
;HH 
iHH 
<HH 
firstHH 
.HH 
LengthHH #
;HH# $
iHH% &
++HH& (
)HH( )
thisHH* .
.HH. /
readHH/ 3
(HH3 4
)HH4 5
;HH5 6
returnII 	
trueII
 
;II 
}JJ 
foreachLL 	
(LL
 
varLL 
sLL 
inLL 
restLL 
)LL 
{LL 
ifMM 
(MM 
thisMM 
.MM 
aheadIsMM 
(MM 
sMM 
)MM 
)MM 
{MM 
forNN 
(NN 	
intNN	 
iNN 
=NN 
$numNN 
;NN 
iNN 
<NN 
sNN 
.NN 
LengthNN  
;NN  !
iNN" #
++NN# %
)NN% &
thisNN' +
.NN+ ,
readNN, 0
(NN0 1
)NN1 2
;NN2 3
returnOO 

trueOO 
;OO 
}PP 
}QQ 
returnSS 
falseSS	 
;SS 
}TT 
privateVV 
boolVV	 

tryConsumeVV 
(VV 
charVV 
firstVV #
,VV# $
paramsVV% +
charVV, 0
[VV0 1
]VV1 2
restVV3 7
)VV7 8
{VV9 :
ifWW 
(WW 
thisWW 

.WW
 
chWW 
==WW 
firstWW 
)WW 
{WW 
thisXX 
.XX 
readXX 
(XX 
)XX 
;XX 
returnYY 	
trueYY
 
;YY 
}ZZ 
elseZZ 
{ZZ	 

foreach[[ 

([[ 
var[[ 
c[[ 
in[[ 
rest[[ 
)[[ 
{[[ 
if\\ 
(\\ 
c\\ 	
==\\
 
this\\ 
.\\ 
ch\\ 
)\\ 
{\\ 
this]] 	
.]]	 

read]]
 
(]] 
)]] 
;]] 
return^^ 
true^^ 
;^^ 
}__ 
}`` 
}aa 
returnbb 
falsebb	 
;bb 
}cc 
privateee 
Resultee	 
<ee 
stringee 
>ee 
readNameee  
(ee  !
)ee! "
{ee# $
ifff 
(ff 
thisff 

.ff
 
chff 
!=ff 
$charff 
&&ff 
!ff 
charff 
.ff 
IsLetterff &
(ff& '
thisff' +
.ff+ ,
chff, .
)ff. /
)ff/ 0
returnff1 7
newff8 ;
ErrInvalidNameff< J
(ffJ K
thisffK O
.ffO P
lineffP T
)ffT U
;ffU V
vargg 
startgg 
=gg 
thisgg 
.gg 
posgg 
;gg 
thishh 
.hh 
readhh 
(hh 
)hh 
;hh 
whileii 
(ii 	
thisii	 
.ii 
chii 
==ii 
$charii 
||ii 
charii 
.ii  
IsLetterOrDigitii  /
(ii/ 0
thisii0 4
.ii4 5
chii5 7
)ii7 8
)ii8 9
thisii: >
.ii> ?
readii? C
(iiC D
)iiD E
;iiE F
returnjj 
thisjj	 
.jj 
inputjj 
.jj 
	Substringjj 
(jj 
startjj #
,jj# $
thisjj% )
.jj) *
posjj* -
-jj. /
startjj0 5
)jj5 6
;jj6 7
}kk 
privatemm 
Resultmm	 
<mm 
	Expansionmm 
>mm 
parseNormalExpandmm ,
(mm, -
)mm- .
{mm/ 0
varnn 
resnn 	
=nn
 
thisnn 
.nn 
readNamenn 
(nn 
)nn 
;nn 
ifoo 
(oo 
resoo 	
.oo	 

IsErroo
 
)oo 
returnoo 
resoo 
.oo 
Erroo 
;oo  
elsepp 
returnpp 
newpp 
	Expansionpp 
(pp 
respp 
.pp  
Okpp  "
)pp" #
;pp# $
}qq 
privatess 
Resultss	 
<ss 
	Expansionss 
>ss 
parseBracedExpandss ,
(ss, -
)ss- .
{ss/ 0
vartt 
lntt 
=tt	 

thistt 
.tt 
linett 
;tt 
thisuu 
.uu 
expectuu 
(uu 
$charuu 
)uu 
;uu 
stringvv 
leftvv	 
;vv 
varww 
leftResww 
=ww 
thisww 
.ww 
readNameww 
(ww 
)ww 
;ww  
ifxx 
(xx 
leftResxx 
.xx 
IsErrxx 
)xx 
returnxx 
leftResxx #
.xx# $
Errxx$ '
;xx' (
elseyy 
ifyy 	
(yy
 
stringyy 
.yy 
IsNullOrEmptyyy 
(yy  
leftResyy  '
.yy' (
Okyy( *
)yy* +
)yy+ ,
returnyy- 3
newyy4 7
ErrBadSubstitutionyy8 J
(yyJ K
lnyyK M
)yyM N
;yyN O
elsezz 
leftzz 
=zz 
leftReszz 
.zz 
Okzz 
;zz 
var}} 
op}} 
=}}	 

ExpansionOp}} 
.}} 
	OrNothing}}  
;}}  !
if~~ 
(~~ 
this~~ 

.~~
 

tryConsume~~ 
(~~ 
$str~~ 
,~~ 
$str~~ 
)~~  
)~~  !
op 
= 
ExpansionOp 
. 
	OrDefault 
; 
else
 
if
 	
(

 
this
 
.
 

tryConsume
 
(
 
$str
 
,
 
$str
  $
)
$ %
)
% &
op
 
=
 
ExpansionOp
 
.
 

AndReplace
 
;
 
else
 
if
 	
(

 
this
 
.
 

tryConsume
 
(
 
$str
 
,
 
$str
  $
)
$ %
)
% &
op
 
=
 
ExpansionOp
 
.
 
OrError
 
;
 
else
 
if
 	
(

 
this
 
.
 

tryConsume
 
(
 
$char
 
)
 
)
  
return
 	
new

 
	Expansion
 
(
 
left
 
,
 
op
  
,
  !
new
" %
Value
& +
(
+ ,
)
, -
)
- .
;
. /
else
 
return
 	
new

 
ErrMissingRBrace
 
(
 
ln
 !
)
! "
;
" #
if
 
(
 
this
 

.

 

tryConsume
 
(
 
$char
 
)
 
)
 
return
 "
new
# &
	Expansion
' 0
(
0 1
left
1 5
,
5 6
op
7 9
,
9 :
new
; >
Value
? D
(
D E
)
E F
)
F G
;
G H
var
 
res
 	
=

 
this
 
.
 !
parseExpansionValue
 $
(
$ %
)
% &
;
& '
if
 
(
 
res
 	
.
	 

IsErr

 
)
 
return
 
res
 
.
 
Err
 
;
  
this
 
.
 
expect
 
(
 
$char
 
)
 
;
 
return
 
new
	 
	Expansion
 
(
 
left
 
,
 
op
 
,
  
res
! $
.
$ %
Ok
% '
)
' (
;
( )
}
 
private
 
Result
	 
<
 
	Expansion
 
>
 
parseExpand
 &
(
& '
)
' (
{
) *
this
 
.
 
expect
 
(
 
$char
 
)
 
;
 
if
 
(
 
this
 

.

 
ch
 
==
 
$char
 
)
 
return
 
this
 !
.
! "
parseBracedExpand
" 3
(
3 4
)
4 5
;
5 6
else
 
return
 
this
 
.
 
parseNormalExpand
 $
(
$ %
)
% &
;
& '
}
 
private
 
Result
	 
<
 
Value
 
>
 !
parseExpansionValue
 *
(
* +
)
+ ,
{
- .
var
 
ln
 
=
	 

this
 
.
 
line
 
;
 
var
 
vals
 

=
 
new
 
Value
 
(
 
)
 
;
 
while
 
(
 	
this
	 
.
 
ch
 
!=
 
$char
 
)
 
{
 
switch
 	
(

 
this
 
.
 
ch
 
)
 
{
 
case
 
EOF
	 
:
 
return
 
new
 
ErrMissingRBrace
  
(
  !
ln
! #
)
# $
;
$ %
case
 
$char
	 
:
 
var
กก 
resD
กก	 
=
กก 
this
กก 
.
กก 
readDoubleQuote
กก $
(
กก$ %
)
กก% &
;
กก& '
if
ขข 
(
ขข 	
resD
ขข	 
.
ขข 
IsErr
ขข 
)
ขข 
return
ขข 
resD
ขข  
.
ขข  !
Err
ขข! $
;
ขข$ %
else
ฃฃ 	
vals
ฃฃ
 
.
ฃฃ 
Add
ฃฃ 
(
ฃฃ 
resD
ฃฃ 
.
ฃฃ 
Ok
ฃฃ 
)
ฃฃ 
;
ฃฃ 
break
คค 

;
คค
 
case
ฅฅ 
$char
ฅฅ	 
:
ฅฅ 
var
ฆฆ 
resS
ฆฆ	 
=
ฆฆ 
this
ฆฆ 
.
ฆฆ 
readSingleQuote
ฆฆ $
(
ฆฆ$ %
)
ฆฆ% &
;
ฆฆ& '
if
งง 
(
งง 	
resS
งง	 
.
งง 
IsErr
งง 
)
งง 
return
งง 
resS
งง  
.
งง  !
Err
งง! $
;
งง$ %
else
จจ 	
vals
จจ
 
.
จจ 
Add
จจ 
(
จจ 
resS
จจ 
.
จจ 
Ok
จจ 
)
จจ 
;
จจ 
break
ฉฉ 

;
ฉฉ
 
case
ชช 
$char
ชช	 
when
ชช 
char
ชช 
.
ชช 
IsDigit
ชช 
(
ชช 
this
ชช #
.
ชช# $
peek
ชช$ (
)
ชช( )
:
ชช) *
this
ซซ 	
.
ซซ	 

read
ซซ
 
(
ซซ 
)
ซซ 
;
ซซ 
this
ฌฌ 	
.
ฌฌ	 

	skipWhile
ฌฌ
 
(
ฌฌ 
c
ฌฌ 
=>
ฌฌ 
char
ฌฌ 
.
ฌฌ 
IsDigit
ฌฌ %
(
ฌฌ% &
c
ฌฌ& '
)
ฌฌ' (
)
ฌฌ( )
;
ฌฌ) *
break
ญญ 

;
ญญ
 
case
ฎฎ 
$char
ฎฎ	 
when
ฎฎ 
this
ฎฎ 
.
ฎฎ 
peek
ฎฎ 
!=
ฎฎ 
$char
ฎฎ "
&&
ฎฎ# %
this
ฎฎ& *
.
ฎฎ* +
peek
ฎฎ+ /
!=
ฎฎ0 2
$char
ฎฎ3 6
&&
ฎฎ7 9
!
ฎฎ: ;
char
ฎฎ; ?
.
ฎฎ? @
IsLetter
ฎฎ@ H
(
ฎฎH I
this
ฎฎI M
.
ฎฎM N
peek
ฎฎN R
)
ฎฎR S
:
ฎฎS T
vals
ฏฏ 	
.
ฏฏ	 

Add
ฏฏ
 
(
ฏฏ 
new
ฏฏ 

StrLiteral
ฏฏ 
(
ฏฏ 
$str
ฏฏ  
)
ฏฏ  !
)
ฏฏ! "
;
ฏฏ" #
this
ฐฐ 	
.
ฐฐ	 

read
ฐฐ
 
(
ฐฐ 
)
ฐฐ 
;
ฐฐ 
break
ฑฑ 

;
ฑฑ
 
case
ฒฒ 
$char
ฒฒ	 
:
ฒฒ 
var
ณณ 
res
ณณ	 
=
ณณ 
this
ณณ 
.
ณณ 
parseExpand
ณณ 
(
ณณ  
)
ณณ  !
;
ณณ! "
if
ดด 
(
ดด 	
res
ดด	 
.
ดด 
IsErr
ดด 
)
ดด 
return
ดด 
res
ดด 
.
ดด 
Err
ดด "
;
ดด" #
else
ตต 	
vals
ตต
 
.
ตต 
Add
ตต 
(
ตต 
res
ตต 
.
ตต 
Ok
ตต 
)
ตต 
;
ตต 
break
ถถ 

;
ถถ
 
case
ทท 
$char
ทท	 
:
ทท 
this
ธธ 	
.
ธธ	 

read
ธธ
 
(
ธธ 
)
ธธ 
;
ธธ 
if
นน 
(
นน 	
this
นน	 
.
นน 
ch
นน 
!=
นน 
$char
นน 
)
นน 
vals
บบ 

.
บบ
 
Add
บบ 
(
บบ 
new
บบ 

StrLiteral
บบ 
(
บบ 
this
บบ "
.
บบ" #
ch
บบ# %
.
บบ% &
ToString
บบ& .
(
บบ. /
)
บบ/ 0
)
บบ0 1
)
บบ1 2
;
บบ2 3
this
ปป 	
.
ปป	 

read
ปป
 
(
ปป 
)
ปป 
;
ปป 
break
ผผ 

;
ผผ
 
default
ฝฝ 
:
ฝฝ 
if
พพ 
(
พพ 	
char
พพ	 
.
พพ 
IsWhiteSpace
พพ 
(
พพ 
this
พพ 
.
พพ  
ch
พพ  "
)
พพ" #
)
พพ# $
{
พพ% &
vals
ฟฟ 

.
ฟฟ
 
Add
ฟฟ 
(
ฟฟ 
new
ฟฟ 

StrLiteral
ฟฟ 
(
ฟฟ 
$str
ฟฟ !
)
ฟฟ! "
)
ฟฟ" #
;
ฟฟ# $
this
ภภ 

.
ภภ
 
	skipWhile
ภภ 
(
ภภ 
c
ภภ 
=>
ภภ 
char
ภภ 
.
ภภ 
IsWhiteSpace
ภภ +
(
ภภ+ ,
c
ภภ, -
)
ภภ- .
)
ภภ. /
;
ภภ/ 0
}
มม 
else
มม 
{
มม 
vals
ยย 

.
ยย
 
Add
ยย 
(
ยย 
new
ยย 

StrLiteral
ยย 
(
ยย 
this
รร 
.
รร 	
	readWhile
รร	 
(
รร 
c
รร 
=>
รร 
!
รร 
	isSpecial
รร "
(
รร" #
c
รร# $
)
รร$ %
&&
รร& (
c
รร) *
!=
รร+ -
$char
รร. 1
&&
รร2 4
!
รร5 6
char
รร6 :
.
รร: ;
IsWhiteSpace
รร; G
(
รรG H
c
รรH I
)
รรI J
)
รรJ K
)
ฤฤ 
)
ฤฤ 
;
ฤฤ 	
}
ลล 
break
ฦฦ 

;
ฦฦ
 
}
วว 
}
ศศ 
return
ฬฬ 
vals
ฬฬ	 
;
ฬฬ 
}
ออ 
private
ฯฯ 
Result
ฯฯ	 
<
ฯฯ 

StrLiteral
ฯฯ 
>
ฯฯ 
readSingleQuote
ฯฯ +
(
ฯฯ+ ,
)
ฯฯ, -
{
ฯฯ. /
var
ะะ 
ln
ะะ 
=
ะะ	 

this
ะะ 
.
ะะ 
line
ะะ 
;
ะะ 
this
ัั 
.
ัั 
expect
ัั 
(
ัั 
$char
ัั 
)
ัั 
;
ัั 
var
าา 
start
าา 
=
าา 
this
าา 
.
าา 
pos
าา 
;
าา 
while
ำำ 
(
ำำ 	
this
ำำ	 
.
ำำ 
ch
ำำ 
!=
ำำ 
$char
ำำ 
)
ำำ 
{
ำำ 
if
ิิ 
(
ิิ 
this
ิิ 
.
ิิ 
ch
ิิ 
==
ิิ 
EOF
ิิ 
)
ิิ 
return
ิิ 
new
ิิ !
ErrUnclosedQuote
ิิ" 2
(
ิิ2 3
ln
ิิ3 5
)
ิิ5 6
;
ิิ6 7
this
ีี 
.
ีี 
read
ีี 
(
ีี 
)
ีี 
;
ีี 
}
ึึ 
var
ืื 
s
ืื 
=
ืื 	
this
ืื
 
.
ืื 
input
ืื 
.
ืื 
	Substring
ืื 
(
ืื 
start
ืื $
,
ืื$ %
this
ืื& *
.
ืื* +
pos
ืื+ .
-
ืื/ 0
start
ืื1 6
)
ืื6 7
;
ืื7 8
this
ุุ 
.
ุุ 
expect
ุุ 
(
ุุ 
$char
ุุ 
)
ุุ 
;
ุุ 
return
ูู 
new
ูู	 

StrLiteral
ูู 
(
ูู 
s
ูู 
)
ูู 
;
ูู 
}
ฺฺ 
private
 
Result
	 
<
 
Value
 
>
 
readDoubleQuote
 &
(
& '
)
' (
{
) *
var
 
ln
 
=
	 

this
 
.
 
line
 
;
 
this
 
.
 
expect
 
(
 
$char
 
)
 
;
 
var
เเ 
buf
เเ 	
=
เเ
 
new
เเ 
StringBuilder
เเ 
(
เเ 
)
เเ 
;
เเ  
var
แแ 
vals
แแ 

=
แแ 
new
แแ 
Value
แแ 
(
แแ 
)
แแ 
;
แแ 
while
ใใ 
(
ใใ 	
this
ใใ	 
.
ใใ 
ch
ใใ 
!=
ใใ 
$char
ใใ 
)
ใใ 
{
ใใ 
switch
ไไ 	
(
ไไ
 
this
ไไ 
.
ไไ 
ch
ไไ 
)
ไไ 
{
ไไ 
case
ๅๅ 
EOF
ๅๅ	 
:
ๅๅ 
return
ๆๆ 
new
ๆๆ 
ErrUnclosedQuote
ๆๆ  
(
ๆๆ  !
ln
ๆๆ! #
)
ๆๆ# $
;
ๆๆ$ %
case
่่ 
$char
่่	 
when
่่ 
char
่่ 
.
่่ 
IsDigit
่่ 
(
่่ 
this
่่ #
.
่่# $
peek
่่$ (
)
่่( )
:
่่) *
this
้้ 	
.
้้	 

read
้้
 
(
้้ 
)
้้ 
;
้้ 
this
๊๊ 	
.
๊๊	 

	skipWhile
๊๊
 
(
๊๊ 
c
๊๊ 
=>
๊๊ 
char
๊๊ 
.
๊๊ 
IsDigit
๊๊ %
(
๊๊% &
c
๊๊& '
)
๊๊' (
)
๊๊( )
;
๊๊) *
continue
๋๋ 
;
๋๋ 
case
์์ 
$char
์์	 
when
์์ 
this
์์ 
.
์์ 
peek
์์ 
!=
์์ 
$char
์์ "
&&
์์# %
this
์์& *
.
์์* +
peek
์์+ /
!=
์์0 2
$char
์์3 6
&&
์์7 9
!
์์: ;
char
์์; ?
.
์์? @
IsLetter
์์@ H
(
์์H I
this
์์I M
.
์์M N
peek
์์N R
)
์์R S
:
์์S T
buf
ํํ 
.
ํํ 	
Append
ํํ	 
(
ํํ 
$char
ํํ 
)
ํํ 
;
ํํ 
this
๎๎ 	
.
๎๎	 

read
๎๎
 
(
๎๎ 
)
๎๎ 
;
๎๎ 
break
๏๏ 

;
๏๏
 
case
๐๐ 
$char
๐๐	 
:
๐๐ 
var
๑๑ 
res
๑๑	 
=
๑๑ 
this
๑๑ 
.
๑๑ 
parseExpand
๑๑ 
(
๑๑  
)
๑๑  !
;
๑๑! "
if
๒๒ 
(
๒๒ 	
res
๒๒	 
.
๒๒ 
IsErr
๒๒ 
)
๒๒ 
return
๒๒ 
res
๒๒ 
.
๒๒ 
Err
๒๒ "
;
๒๒" #
if
๓๓ 
(
๓๓ 	
buf
๓๓	 
.
๓๓ 
Length
๓๓ 
!=
๓๓ 
$num
๓๓ 
)
๓๓ 
{
๓๓ 
vals
๔๔ 

.
๔๔
 
Add
๔๔ 
(
๔๔ 
new
๔๔ 

StrLiteral
๔๔ 
(
๔๔ 
buf
๔๔ !
.
๔๔! "
ToString
๔๔" *
(
๔๔* +
)
๔๔+ ,
)
๔๔, -
)
๔๔- .
;
๔๔. /
buf
๕๕ 	
.
๕๕	 

Clear
๕๕
 
(
๕๕ 
)
๕๕ 
;
๕๕ 
}
๖๖ 
vals
๗๗ 	
.
๗๗	 

Add
๗๗
 
(
๗๗ 
res
๗๗ 
.
๗๗ 
Ok
๗๗ 
)
๗๗ 
;
๗๗ 
continue
๘๘ 
;
๘๘ 
case
๙๙ 
$char
๙๙	 
when
๙๙ 
this
๙๙ 
.
๙๙ 
peek
๙๙ 
==
๙๙ 
$char
๙๙  $
:
๙๙$ %
this
๚๚ 	
.
๚๚	 

read
๚๚
 
(
๚๚ 
)
๚๚ 
;
๚๚ 
break
๛๛ 

;
๛๛
 
case
 
$char
	 
:
 
this
 	
.
	 

read

 
(
 
)
 
;
 
buf
 
.
 	
Append
	 
(
 
escaped
 
(
 
this
 
.
 
ch
 
)
  
)
  !
;
! "
break
 

;

 
default
 
:
 
buf
 
.
 	
Append
	 
(
 
this
 
.
 
ch
 
)
 
;
 
break
 

;

 
}
 
this
 
.
 
read
 
(
 
)
 
;
 
}
 
this
 
.
 
expect
 
(
 
$char
 
)
 
;
 
if
 
(
 
buf
 	
.
	 

Length

 
!=
 
$num
 
)
 
vals
 
.
 
Add
 
(
  
new
  #

StrLiteral
$ .
(
. /
buf
/ 2
.
2 3
ToString
3 ;
(
; <
)
< =
)
= >
)
> ?
;
? @
return
 
vals
	 
;
 
}
 
private
 
Result
	 
<
 
Value
 
>
 

parseValue
 !
(
! "
)
" #
{
$ %
var
 
vals
 

=
 
new
 
Value
 
(
 
)
 
;
 
while
 
(
 	
this
	 
.
 
ch
 
!=
 
EOF
 
&&
 
!
 
char
  
.
  !
IsWhiteSpace
! -
(
- .
this
. 2
.
2 3
ch
3 5
)
5 6
)
6 7
{
8 9
switch
 	
(

 
this
 
.
 
ch
 
)
 
{
 
case
 
$char
	 
:
 
var
 
resD
	 
=
 
this
 
.
 
readDoubleQuote
 $
(
$ %
)
% &
;
& '
if
 
(
 	
resD
	 
.
 
IsErr
 
)
 
return
 
resD
  
.
  !
Err
! $
;
$ %
else
 	
vals

 
.
 
Add
 
(
 
resD
 
.
 
Ok
 
)
 
;
 
break
 

;

 
case
 
$char
	 
:
 
var
 
resS
	 
=
 
this
 
.
 
readSingleQuote
 $
(
$ %
)
% &
;
& '
if
 
(
 	
resS
	 
.
 
IsErr
 
)
 
return
 
resS
  
.
  !
Err
! $
;
$ %
else
 	
vals

 
.
 
Add
 
(
 
resS
 
.
 
Ok
 
)
 
;
 
break
 

;

 
case
 
$char
	 
when
 
char
 
.
 
IsDigit
 
(
 
this
 #
.
# $
peek
$ (
)
( )
:
) *
this
 	
.
	 

read

 
(
 
)
 
;
 
this
 	
.
	 

	skipWhile

 
(
 
c
 
=>
 
char
 
.
 
IsDigit
 %
(
% &
c
& '
)
' (
)
( )
;
) *
break
กก 

;
กก
 
case
ขข 
$char
ขข	 
when
ขข 
this
ขข 
.
ขข 
peek
ขข 
!=
ขข 
$char
ขข "
&&
ขข# %
this
ขข& *
.
ขข* +
peek
ขข+ /
!=
ขข0 2
$char
ขข3 6
&&
ขข7 9
!
ขข: ;
char
ขข; ?
.
ขข? @
IsLetter
ขข@ H
(
ขขH I
this
ขขI M
.
ขขM N
peek
ขขN R
)
ขขR S
:
ขขS T
vals
ฃฃ 	
.
ฃฃ	 

Add
ฃฃ
 
(
ฃฃ 
new
ฃฃ 

StrLiteral
ฃฃ 
(
ฃฃ 
$str
ฃฃ  
)
ฃฃ  !
)
ฃฃ! "
;
ฃฃ" #
this
คค 	
.
คค	 

read
คค
 
(
คค 
)
คค 
;
คค 
break
ฅฅ 

;
ฅฅ
 
case
ฆฆ 
$char
ฆฆ	 
:
ฆฆ 
var
งง 
res
งง	 
=
งง 
this
งง 
.
งง 
parseExpand
งง 
(
งง  
)
งง  !
;
งง! "
if
จจ 
(
จจ 	
res
จจ	 
.
จจ 
IsErr
จจ 
)
จจ 
return
จจ 
res
จจ 
.
จจ 
Err
จจ "
;
จจ" #
else
ฉฉ 	
vals
ฉฉ
 
.
ฉฉ 
Add
ฉฉ 
(
ฉฉ 
res
ฉฉ 
.
ฉฉ 
Ok
ฉฉ 
)
ฉฉ 
;
ฉฉ 
break
ชช 

;
ชช
 
case
ซซ 
$char
ซซ	 
:
ซซ 
if
ฌฌ 
(
ฌฌ 	
this
ฌฌ	 
.
ฌฌ 
peek
ฌฌ 
==
ฌฌ 
$char
ฌฌ 
)
ฌฌ 
{
ฌฌ 
this
ญญ 

.
ญญ
 
read
ญญ 
(
ญญ 
)
ญญ 
;
ญญ 
this
ฎฎ 

.
ฎฎ
 
read
ฎฎ 
(
ฎฎ 
)
ฎฎ 
;
ฎฎ 
if
ฏฏ 
(
ฏฏ	 

vals
ฏฏ
 
.
ฏฏ 
Count
ฏฏ 
==
ฏฏ 
$num
ฏฏ 
)
ฏฏ 
{
ฏฏ 
this
ฐฐ 
.
ฐฐ 
	skipSpace
ฐฐ 
(
ฐฐ 
)
ฐฐ 
;
ฐฐ 
continue
ฑฑ 
;
ฑฑ 
}
ฒฒ 
}
ณณ 
else
ณณ 
{
ณณ 
this
ดด 

.
ดด
 
read
ดด 
(
ดด 
)
ดด 
;
ดด 
vals
ตต 

.
ตต
 
Add
ตต 
(
ตต 
new
ตต 

StrLiteral
ตต 
(
ตต 
this
ตต "
.
ตต" #
ch
ตต# %
.
ตต% &
ToString
ตต& .
(
ตต. /
)
ตต/ 0
)
ตต0 1
)
ตต1 2
;
ตต2 3
}
ถถ 
break
ทท 

;
ทท
 
default
ธธ 
:
ธธ 
vals
นน 	
.
นน	 

Add
นน
 
(
นน 
new
นน 

StrLiteral
นน 
(
นน 
this
บบ 	
.
บบ	 

	readWhile
บบ
 
(
บบ 
c
บบ 
=>
บบ 
!
บบ 
char
บบ 
.
บบ 
IsWhiteSpace
บบ +
(
บบ+ ,
c
บบ, -
)
บบ- .
&&
บบ/ 1
!
บบ2 3
	isSpecial
บบ3 <
(
บบ< =
c
บบ= >
)
บบ> ?
)
บบ? @
)
ปป 
)
ปป 
;
ปป 
break
ผผ 

;
ผผ
 
}
ฝฝ 
}
พพ 
return
ฟฟ 
vals
ฟฟ	 
;
ฟฟ 
}
ภภ 
private
ยย 
Result
ยย	 
<
ยย 
Entry
ยย 
>
ยย 

parseEntry
ยย !
(
ยย! "
)
ยย" #
{
ยย$ %
var
รร 
ln
รร 
=
รร	 

this
รร 
.
รร 
line
รร 
;
รร 
this
ฤฤ 
.
ฤฤ 

tryConsume
ฤฤ 
(
ฤฤ 
$str
ฤฤ 
,
ฤฤ 
$str
ฤฤ '
)
ฤฤ' (
;
ฤฤ( )
this
ลล 
.
ลล 
	skipSpace
ลล 
(
ลล 
)
ลล 
;
ลล 
var
ฦฦ 
name
ฦฦ 

=
ฦฦ 
this
ฦฦ 
.
ฦฦ 
readName
ฦฦ 
(
ฦฦ 
)
ฦฦ 
;
ฦฦ 
if
วว 
(
วว 
name
วว 

.
วว
 
IsErr
วว 
)
วว 
return
วว 
name
วว 
.
วว 
Err
วว !
;
วว! "
this
ษษ 
.
ษษ 
	skipSpace
ษษ 
(
ษษ 
)
ษษ 
;
ษษ 
if
หห 
(
หห 
this
หห 

.
หห
 
ch
หห 
!=
หห 
$char
หห 
)
หห 
return
หห 
new
หห  
ErrMissingEquals
หห! 1
(
หห1 2
ln
หห2 4
)
หห4 5
;
หห5 6
this
ฬฬ 
.
ฬฬ 
read
ฬฬ 
(
ฬฬ 
)
ฬฬ 
;
ฬฬ 
this
ออ 
.
ออ 
	skipSpace
ออ 
(
ออ 
)
ออ 
;
ออ 
if
ฯฯ 
(
ฯฯ 
this
ฯฯ 

.
ฯฯ
 
ch
ฯฯ 
==
ฯฯ 
$char
ฯฯ 
||
ฯฯ 
this
ฯฯ 
.
ฯฯ 
ch
ฯฯ  
==
ฯฯ! #
EOF
ฯฯ$ '
)
ฯฯ' (
{
ฯฯ) *
return
ะะ 	
new
ะะ
 
Entry
ะะ 
(
ะะ 
name
ะะ 
.
ะะ 
Ok
ะะ 
,
ะะ 
new
ะะ  
Value
ะะ! &
(
ะะ& '
)
ะะ' (
)
ะะ( )
;
ะะ) *
}
ัั 
var
ำำ 
res
ำำ 	
=
ำำ
 
this
ำำ 
.
ำำ 

parseValue
ำำ 
(
ำำ 
)
ำำ 
;
ำำ 
if
ิิ 
(
ิิ 
res
ิิ 	
.
ิิ	 

IsErr
ิิ
 
)
ิิ 
return
ิิ 
res
ิิ 
.
ิิ 
Err
ิิ 
;
ิิ  
this
ีี 
.
ีี 
	skipSpace
ีี 
(
ีี 
)
ีี 
;
ีี 
if
ึึ 
(
ึึ 
this
ึึ 

.
ึึ
 
ch
ึึ 
!=
ึึ 
$char
ึึ 
&&
ึึ 
this
ึึ 
.
ึึ 
ch
ึึ  
!=
ึึ! #
$char
ึึ$ '
&&
ึึ( *
this
ึึ+ /
.
ึึ/ 0
ch
ึึ0 2
!=
ึึ3 5
EOF
ึึ6 9
)
ึึ9 :
{
ึึ; <
return
ืื 	
new
ืื
 
ErrMissingNewline
ืื 
(
ืื  
this
ืื  $
.
ืื$ %
line
ืื% )
)
ืื) *
;
ืื* +
}
ุุ 
return
ูู 
new
ูู	 
Entry
ูู 
(
ูู 
name
ูู 
.
ูู 
Ok
ูู 
,
ูู 
res
ูู 
.
ูู  
Ok
ูู  "
)
ูู" #
;
ูู# $
}
ฺฺ 
public
 
IEnumerator
 
<
 
Result
 
<
 
Entry
  
>
  !
>
! "
GetEnumerator
# 0
(
0 1
)
1 2
{
3 4
while
 
(
 	
this
	 
.
 
ch
 
!=
 
EOF
 
)
 
{
 
this
 
.
 
	skipWhile
 
(
 
c
 
=>
 
char
 
.
 
IsWhiteSpace
 (
(
( )
c
) *
)
* +
)
+ ,
;
, -
if
฿฿ 
(
฿฿ 
this
฿฿ 
.
฿฿ 
ch
฿฿ 
==
฿฿ 
$char
฿฿ 
)
฿฿ 
{
฿฿ 
this
เเ 
.
เเ 	
skipLine
เเ	 
(
เเ 
)
เเ 
;
เเ 
continue
แแ 
;
แแ 
}
โโ 
if
ใใ 
(
ใใ 
this
ใใ 
.
ใใ 
ch
ใใ 
==
ใใ 
EOF
ใใ 
)
ใใ 
break
ใใ 
;
ใใ 
var
ไไ 
res
ไไ 

=
ไไ 
this
ไไ 
.
ไไ 

parseEntry
ไไ 
(
ไไ 
)
ไไ 
;
ไไ 
if
ๅๅ 
(
ๅๅ 
res
ๅๅ 

.
ๅๅ
 
IsErr
ๅๅ 
)
ๅๅ 
this
ๅๅ 
.
ๅๅ 
skipLine
ๅๅ 
(
ๅๅ  
)
ๅๅ  !
;
ๅๅ! "
yield
ๆๆ 
return
ๆๆ	 
res
ๆๆ 
;
ๆๆ 
}
็็ 
}
่่ 
IEnumerator
๊๊ 
IEnumerable
๊๊ 
.
๊๊ 
GetEnumerator
๊๊ &
(
๊๊& '
)
๊๊' (
=>
๊๊) +
GetEnumerator
๊๊, 9
(
๊๊9 :
)
๊๊: ;
;
๊๊; <
}๋๋ 
,D:\home\projects\ps-dotenv\Parsing\Result.cs
	namespace 	
Dotenv
 
. 
Parsing 
; 
public 
class 
Result 
< 
T 
> 
{ 
public 
T 	
?	 

Ok 
{ 
get 
; 
set 
; 
} 
public 

ParseError 
? 
Err 
{ 
get 
; 
set "
;" #
}$ %
public 
bool 
IsErr 
=> 
this 
. 
Err 
is !
not" %
null& *
;* +
public 
Result 
( 
T 
ok 
) 
=> 
( 
this 
. 
Ok  
,  !
this" &
.& '
Err' *
)* +
=, -
(. /
ok/ 1
,1 2
null3 7
)7 8
;8 9
public		 
Result		 
(		 

ParseError		 
err		 
)		 
=>		 !
(		" #
this		# '
.		' (
Ok		( *
,		* +
this		, 0
.		0 1
Err		1 4
)		4 5
=		6 7
(		8 9
default		9 @
(		@ A
T		A B
)		B C
,		C D
err		E H
)		H I
;		I J
public 
static 
implicit 
operator  
Result! '
<' (
T( )
>) *
(* +
T+ ,
ok- /
)/ 0
=>1 3
new4 7
Result8 >
<> ?
T? @
>@ A
(A B
okB D
)D E
;E F
public 
static 
implicit 
operator  
Result! '
<' (
T( )
>) *
(* +

ParseError+ 5
e6 7
)7 8
=>9 ;
new< ?
Result@ F
<F G
TG H
>H I
(I J
eJ K
)K L
;L M
} ก@
)D:\home\projects\ps-dotenv\Parsing\str.cs
	namespace 	
Dotenv
 
. 
Parsing 
; 
internal 
enum	 
ExpansionOp 
{ 
	OrNothing 

,
 
	OrDefault 

,
 
OrError 
, 	

AndReplace		 
,		 
}

 
	interface 	
Expr
 
{ 
string 
ExpandValue 
( 
) 
; 
} 
internal 
readonly	 
struct 

StrLiteral #
:# $
Expr% )
{* +
private 
readonly	 
string 
val 
{ 
get "
;" #
init$ (
;( )
}* +
public 

StrLiteral 
( 
string 
s 
) 
=> 
this  $
.$ %
val% (
=) *
s+ ,
;, -
public 
static 
implicit 
operator  

StrLiteral! +
(+ ,
string, 2
s3 4
)4 5
=>6 8
new9 <

StrLiteral= G
(G H
sH I
)I J
;J K
public 
string 
ExpandValue 
( 
) 
=> 
this  $
.$ %
val% (
;( )
public 
override 
string 
ToString  
(  !
)! "
=># %
this& *
.* +
val+ .
;. /
} 
internal 
class	 
	Expansion 
: 
Expr 
{  
internal 	
	Expansion
 
( 
string 
left 
,  
ExpansionOp! ,
op- /
,/ 0
Value1 6
right7 <
)< =
{> ?
this 
. 
left 
= 
left 
; 
this 
. 
right 
= 
right 
; 
this 
. 
op 	
=
 
op 
; 
}   
internal!! 	
	Expansion!!
 
(!! 
string!! 
name!! 
)!!  
{!!! "
this"" 
."" 
left"" 
="" 
name"" 
;"" 
this## 
.## 
right## 
=## 
new## 
Value## 
(## 
)## 
;## 
this$$ 
.$$ 
op$$ 	
=$$
 
ExpansionOp$$ 
.$$ 
	OrNothing$$ !
;$$! "
}%% 
private'' 
readonly''	 
string'' 
left'' 
;'' 
private(( 
readonly((	 
ExpansionOp(( 
op((  
;((  !
private)) 
readonly))	 
Value)) 
right)) 
;)) 
public++ 
string++ 
ExpandValue++ 
(++ 
)++ 
{++ 
var,, 
s,, 
=,, 	
System,,
 
.,, 
Environment,, 
.,, "
GetEnvironmentVariable,, 3
(,,3 4
this,,4 8
.,,8 9
left,,9 =
??,,> @
$str,,A C
),,C D
;,,D E
switch-- 
(--	 

this--
 
.-- 
op-- 
)-- 
{-- 
case.. 
ExpansionOp.. 
... 
	OrNothing.. 
:.. 
return// 

s// 
;// 
case00 
ExpansionOp00 
.00 
	OrDefault00 
:00 
if11 
(11 
string11 
.11 
IsNullOrEmpty11 
(11 
s11 
)11 
)11  
return11! '
this11( ,
.11, -
right11- 2
.112 3
ExpandValue113 >
(11> ?
)11? @
;11@ A
else22 
return22	 
s22 
;22 
case33 
ExpansionOp33 
.33 

AndReplace33 
:33 
if44 
(44 
string44 
.44 
IsNullOrEmpty44 
(44 
s44 
)44 
)44  
return44! '
$str44( *
;44* +
else55 
return55	 
this55 
.55 
right55 
.55 
ExpandValue55 &
(55& '
)55' (
;55( )
case66 
ExpansionOp66 
.66 
OrError66 
:66 
if77 
(77 
string77 
.77 
IsNullOrEmpty77 
(77 
s77 
)77 
)77  
throw88 

new88 
VarUnsetException88  
(88  !
this88! %
.88% &
left88& *
??88+ -
$str88. 0
,880 1
this882 6
.886 7
right887 <
?88< =
.88= >
ExpandValue88> I
(88I J
)88J K
??88L N
$str88O h
)88h i
;88i j
else99 
return:: 
s:: 
;:: 
default;; 

:;;
 
throw<< 	
new<<
 
AssertionException<<  
(<<  !
$str<<! 6
)<<6 7
;<<7 8
}== 
}>> 
}?? 
internalAA 
classAA	 
ValueAA 
:AA 
ExprAA 
{AA 
privateBB 
ListBB	 
<BB 
ExprBB 
>BB 
	fragmentsBB 
=BB 
newBB  #
(BB# $
)BB$ %
;BB% &
publicCC 
intCC 
CountCC 
=>CC 
thisCC 
.CC 
	fragmentsCC #
.CC# $
CountCC$ )
;CC) *
internalEE 	
ValueEE
 
(EE 
)EE 
{EE 
}EE 
publicGG 
voidGG 
AddGG 
(GG 

StrLiteralGG 
sGG 
)GG 
=>GG !
thisGG" &
.GG& '
	fragmentsGG' 0
.GG0 1
AddGG1 4
(GG4 5
sGG5 6
)GG6 7
;GG7 8
publicHH 
voidHH 
AddHH 
(HH 
	ExpansionHH 
eHH 
)HH 
=>HH  
thisHH! %
.HH% &
	fragmentsHH& /
.HH/ 0
AddHH0 3
(HH3 4
eHH4 5
)HH5 6
;HH6 7
publicII 
voidII 
AddII 
(II 
ValueII 
vII 
)II 
=>II 
thisII !
.II! "
	fragmentsII" +
.II+ ,
AddII, /
(II/ 0
vII0 1
)II1 2
;II2 3
publicKK 
stringKK 
ExpandValueKK 
(KK 
)KK 
{KK 
ifLL 
(LL 
thisLL 

.LL
 
	fragmentsLL 
isLL 
nullLL 
||LL 
thisLL  $
.LL$ %
	fragmentsLL% .
.LL. /
CountLL/ 4
==LL5 7
$numLL8 9
)LL9 :
returnLL; A
$strLLB D
;LLD E
varNN 
bufNN 	
=NN
 
newNN 
StringBuilderNN 
(NN 
)NN 
;NN  
foreachOO 	
(OO
 
varOO 
xOO 
inOO 
thisOO 
.OO 
	fragmentsOO "
)OO" #
bufOO$ '
.OO' (
AppendOO( .
(OO. /
xOO/ 0
.OO0 1
ExpandValueOO1 <
(OO< =
)OO= >
)OO> ?
;OO? @
returnPP 
bufPP	 
.PP 
ToStringPP 
(PP 
)PP 
;PP 
}QQ 
}RR 