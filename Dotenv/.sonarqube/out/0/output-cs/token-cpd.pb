б
'D:\home\projects\ps-dotenv\Parsing\A.cs
	namespace 	
System
 
. 
Runtime 
. 
CompilerServices )
;) *
[ 
EditorBrowsable 
(  
EditorBrowsableState %
.% &
Never& +
)+ ,
], -
internal 
static	 
class 
IsExternalInit $
{% &
}' (√
+D:\home\projects\ps-dotenv\Parsing\Entry.cs
	namespace 	
Dotenv
 
. 
Parsing 
; 
public 
readonly 
struct 
Entry 
{ 
public 
readonly 
string 
Name 
{ 
get "
;" #
init$ (
;( )
}* +
internal 	
readonly
 
Value 
val 
{ 
get "
;" #
init$ (
;( )
}* +
internal 	
Entry
 
( 
string 
name 
, 
Value "
val# &
)& '
=>( *
(+ ,
this, 0
.0 1
Name1 5
,5 6
this7 ;
.; <
val< ?
)? @
=A B
(C D
nameD H
,H I
valJ M
)M N
;N O
public		 
string		 
ExpandValue		 
(		 
)		 
=>		 
this		  $
.		$ %
val		% (
.		( )
ExpandValue		) 4
(		4 5
)		5 6
;		6 7
public

 
void

 
SetEnv

 
(

 
)

 
=>

 
System

 
.

  
Environment

  +
.

+ ,"
SetEnvironmentVariable

, B
(

B C
this

C G
.

G H
Name

H L
,

L M
this

N R
.

R S
ExpandValue

S ^
(

^ _
)

_ `
)

` a
;

a b
} Ж+
,D:\home\projects\ps-dotenv\Parsing\Errors.cs
	namespace 	
Dotenv
 
. 
Parsing 
; 
public 
abstract 
class 

ParseError  
:  !
	Exception" +
{, -
public 
int 
Line 
{ 
get 
; 
set 
; 
} 
public 

ParseError 
( 
int 
line 
, 
string #
msg$ '
)' (
: 
base 
( 
$" 

$str
 
{ 
line 
} 
$str 
{ 
msg 
} 
" 
) 
{  
Line 
= 
line	 
; 
}		 
public 
override 
string 
ToString  
(  !
)! "
=># %
this& *
.* +
Message+ 2
;2 3
} 
public 
class 
ErrInvalidName 
: 

ParseError '
{( )
public 
ErrInvalidName 
( 
int 
line 
)  
: 
base 
( 
line 
, 
$str M
)M N
{O P
}Q R
public 
ErrInvalidName 
( 
int 
line 
,  
string! '
msg( +
)+ ,
: 
base 
( 
line 
, 
msg 
) 
{ 
} 
} 
public 
class 
ErrMissingEquals 
: 

ParseError )
{* +
public 
ErrMissingEquals 
( 
int 
line !
)! "
: 
base 
( 
line 
, 
$str  
)  !
{" #
}$ %
} 
public 
class 
ErrUnclosedQuote 
: 

ParseError )
{* +
public 
ErrUnclosedQuote 
( 
int 
line !
)! "
: 
base 
( 
line 
, 
$str 
) 
{  !
}" #
} 
public   
class   
AssertionException   
:    
	Exception  ! *
{  + ,
public!! 
AssertionException!! 
(!! 
string!! !
msg!!" %
)!!% &
:"" 
base"" 
("" 
$""" 

$str""
  
{""  !
msg""! $
}""$ %
"""% &
)""& '
{""( )
}""* +
}## 
public%% 
class%% 
ErrMissingNewline%% 
:%% 

ParseError%%  *
{%%+ ,
public&& 
ErrMissingNewline&& 
(&& 
int&& 
line&& "
)&&" #
:'' 
base'' 
('' 
line'' 
,'' 
$str'' H
)''H I
{''J K
}''L M
}(( 
public** 
class** 
ErrMissingRBrace** 
:** 

ParseError** )
{*** +
public++ 
ErrMissingRBrace++ 
(++ 
int++ 
line++ !
)++! "
:,, 
base,, 
(,, 
line,, 
,,, 
$str,, H
),,H I
{,,J K
},,L M
}-- 
public// 
class// 
VarUnsetException// 
:// 
	Exception//  )
{//* +
public00 
string00 
VariableName00 
{00 
get00 !
;00! "
private00# *
set00+ .
;00. /
}000 1
public11 
string11 
?11 
Msg11 
{11 
get11 
;11 
private11 "
set11# &
;11& '
}11( )
public33 
VarUnsetException33 
(33 
string33  
name33! %
,33% &
string33' -
?33- .
msg33/ 2
)332 3
:44 
base44 
(44 
$"44 

{44
 
name44 
}44 
$str44 
{44 
msg44 
??44 
$str44 0
}440 1
"441 2
)442 3
{444 5
this55 
.55 
VariableName55 
=55 
name55 
;55 
this66 
.66 
Msg66 

=66 
msg66 
??66 
$str66 -
;66- .
}77 
public99 
override99 
string99 
ToString99  
(99  !
)99! "
=>99# %
base99& *
.99* +
Message99+ 2
;992 3
}:: 
public<< 
class<< 
ErrBadSubstitution<< 
:<<  

ParseError<<! +
{<<, -
public== 
ErrBadSubstitution== 
(== 
int== 
line== #
)==# $
:==% &
base==' +
(==+ ,
line==, 0
,==0 1
$str==2 D
)==D E
{==F G
}==H I
}>> ев
,D:\home\projects\ps-dotenv\Parsing\Parser.cs
	namespace 	
Dotenv
 
. 
Parsing 
; 
public 
class 
Parser 
: 
IEnumerable  
<  !
Result! '
<' (
Entry( -
>- .
>. /
{0 1
public 
Parser 
( 
string 
input 
) 
{ 
this 
. 
input 
= 
input 
. 
Replace 
( 
$str #
,# $
$str% )
)) *
;* +
this		 
.		 
ch		 	
=		
 
this		 
.		 
input		 
.		 
Length		 
>		 
$num		  !
?		" #
this		$ (
.		( )
input		) .
[		. /
$num		/ 0
]		0 1
:		2 3
EOF		4 7
;		7 8
}

 
private 
const	 
char 
EOF 
= 
char 
. 
MinValue '
;' (
private 
string	 
input 
; 
private 
int	 
line 
= 
$num 
; 
private 
int	 
pos 
= 
$num 
; 
private 
char	 
ch 
; 
private 
int	 
readpos 
=> 
this 
. 
pos  
+! "
$num# $
;$ %
private 
char	 
peek 
=> 
this 
. 
readpos "
<# $
this% )
.) *
input* /
./ 0
Length0 6
?7 8
this9 =
.= >
input> C
[C D
thisD H
.H I
readposI P
]P Q
:R S
EOFT W
;W X
private 
void	 
read 
( 
) 
{ 
this 
. 
pos 

++
 
; 
if 
( 
this 

.
 
pos 
>= 
this 
. 
input 
. 
Length #
)# $
{% &
this 
. 
ch 

= 
EOF 
; 
} 
else 
{	 

this 
. 
ch 

= 
this 
. 
input 
[ 
this 
. 
pos  
]  !
;! "
if 
( 
this 
. 
ch 
== 
$char 
) 
this 
. 
line !
++! #
;# $
} 
} 
private   
static  	 
char   
escaped   
(   
char   !
c  " #
)  # $
=>  % '
c  ( )
switch  * 0
{  1 2
$char!! 
=>!! 
$char!!	 
,!! 
$char"" 
=>"" 
$char""	 
,"" 
$char## 
=>## 
$char##	 
,## 
$char$$ 
=>$$ 
$char$$	 
,$$ 
$char%% 
=>%% 
$char%%	 
,%% 
$char&& 
=>&& 
$char&&	 
,&& 
_'' 
=>'' 
c'' 
,'' 	
}(( 
;(( 
private** 
static**	 
bool** 
	isSpecial** 
(** 
char** #
c**$ %
)**% &
=>**' )
c*** +
switch**, 2
{**3 4
$char++ 
or++ 
$char++	 
or++ 
$char++ 
or++ 
$char++ 
=>++ 
true++  $
,++$ %
_,, 
=>,, 
false,, 
,,, 
}-- 
;-- 
private// 
void//	 
skipLine// 
(// 
)// 
=>// 
this//  
.//  !
	skipWhile//! *
(//* +
c//+ ,
=>//- /
c//0 1
!=//2 4
EOF//5 8
&&//9 ;
c//< =
!=//> @
$char//A E
)//E F
;//F G
private00 
void00	 
	skipSpace00 
(00 
)00 
=>00 
this00 !
.00! "
	skipWhile00" +
(00+ ,
c00, -
=>00. 0
c001 2
!=003 5
$char006 :
&&00; =
char00> B
.00B C
IsWhiteSpace00C O
(00O P
c00P Q
)00Q R
)00R S
;00S T
private11 
void11	 
	skipWhile11 
(11 
Func11 
<11 
char11 !
,11! "
bool11# '
>11' (
fn11) +
)11+ ,
{11- .
while22 
(22 	
this22	 
.22 
ch22 
!=22 
EOF22 
&&22 
fn22 
(22 
this22 "
.22" #
ch22# %
)22% &
)22& '
this22( ,
.22, -
read22- 1
(221 2
)222 3
;223 4
}33 
private55 
string55	 
	readWhile55 
(55 
Func55 
<55 
char55 #
,55# $
bool55% )
>55) *
fn55+ -
)55- .
{55/ 0
var66 
start66 
=66 
this66 
.66 
pos66 
;66 
while77 
(77 	
this77	 
.77 
ch77 
!=77 
EOF77 
&&77 
fn77 
(77 
this77 "
.77" #
ch77# %
)77% &
)77& '
this77( ,
.77, -
read77- 1
(771 2
)772 3
;773 4
return88 
this88	 
.88 
input88 
.88 
	Substring88 
(88 
start88 #
,88# $
this88% )
.88) *
pos88* -
-88. /
start880 5
)885 6
;886 7
}99 
private;; 
bool;;	 
aheadIs;; 
(;; 
string;; 
s;; 
);; 
=>;;  "
this;;# '
.;;' (
input;;( -
.;;- .
	Substring;;. 7
(;;7 8
this;;8 <
.;;< =
pos;;= @
);;@ A
.;;A B

StartsWith;;B L
(;;L M
s;;M N
,;;N O
StringComparison;;P `
.;;` a
Ordinal;;a h
);;h i
;;;i j
private== 
void==	 
expect== 
(== 
char== 
c== 
)== 
{== 
if>> 
(>> 
this>> 

.>>
 
ch>> 
!=>> 
c>> 
)>> 
throw>> 
new>> 
AssertionException>> 0
(>>0 1
$">>1 3
$str>>3 :
{>>: ;
c>>; <
}>>< =
$str>>= >
">>> ?
)>>? @
;>>@ A
this?? 
.?? 
read?? 
(?? 
)?? 
;?? 
}@@ 
privateBB 
voidBB	 
expectBB 
(BB 
stringBB 
sBB 
)BB 
{BB  
ifCC 
(CC 
!CC 
thisCC 
.CC 

tryConsumeCC 
(CC 
sCC 
)CC 
)CC 
throwCC  
newCC! $
AssertionExceptionCC% 7
(CC7 8
$"CC8 :
$strCC: A
{CCA B
sCCB C
}CCC D
$strCCD E
"CCE F
)CCF G
;CCG H
}DD 
privateFF 
boolFF	 

tryConsumeFF 
(FF 
stringFF 
firstFF  %
,FF% &
paramsFF' -
stringFF. 4
[FF4 5
]FF5 6
restFF7 ;
)FF; <
{FF= >
ifGG 
(GG 
thisGG 

.GG
 
aheadIsGG 
(GG 
firstGG 
)GG 
)GG 
{GG 
forHH 
(HH 
intHH 
iHH 
=HH 
$numHH 
;HH 
iHH 
<HH 
firstHH 
.HH 
LengthHH #
;HH# $
iHH% &
++HH& (
)HH( )
thisHH* .
.HH. /
readHH/ 3
(HH3 4
)HH4 5
;HH5 6
returnII 	
trueII
 
;II 
}JJ 
foreachLL 	
(LL
 
varLL 
sLL 
inLL 
restLL 
)LL 
{LL 
ifMM 
(MM 
thisMM 
.MM 
aheadIsMM 
(MM 
sMM 
)MM 
)MM 
{MM 
forNN 
(NN 	
intNN	 
iNN 
=NN 
$numNN 
;NN 
iNN 
<NN 
sNN 
.NN 
LengthNN  
;NN  !
iNN" #
++NN# %
)NN% &
thisNN' +
.NN+ ,
readNN, 0
(NN0 1
)NN1 2
;NN2 3
returnOO 

trueOO 
;OO 
}PP 
}QQ 
returnSS 
falseSS	 
;SS 
}TT 
privateVV 
boolVV	 

tryConsumeVV 
(VV 
charVV 
firstVV #
,VV# $
paramsVV% +
charVV, 0
[VV0 1
]VV1 2
restVV3 7
)VV7 8
{VV9 :
ifWW 
(WW 
thisWW 

.WW
 
chWW 
==WW 
firstWW 
)WW 
{WW 
thisXX 
.XX 
readXX 
(XX 
)XX 
;XX 
returnYY 	
trueYY
 
;YY 
}ZZ 
elseZZ 
{ZZ	 

foreach[[ 

([[ 
var[[ 
c[[ 
in[[ 
rest[[ 
)[[ 
{[[ 
if\\ 
(\\ 
c\\ 	
==\\
 
this\\ 
.\\ 
ch\\ 
)\\ 
{\\ 
this]] 	
.]]	 

read]]
 
(]] 
)]] 
;]] 
return^^ 
true^^ 
;^^ 
}__ 
}`` 
}aa 
returnbb 
falsebb	 
;bb 
}cc 
privateee 
Resultee	 
<ee 
stringee 
>ee 
readNameee  
(ee  !
)ee! "
{ee# $
ifff 
(ff 
thisff 

.ff
 
chff 
!=ff 
$charff 
&&ff 
!ff 
charff 
.ff 
IsLetterff &
(ff& '
thisff' +
.ff+ ,
chff, .
)ff. /
)ff/ 0
returnff1 7
newff8 ;
ErrInvalidNameff< J
(ffJ K
thisffK O
.ffO P
lineffP T
)ffT U
;ffU V
vargg 
startgg 
=gg 
thisgg 
.gg 
posgg 
;gg 
thishh 
.hh 
readhh 
(hh 
)hh 
;hh 
whileii 
(ii 	
thisii	 
.ii 
chii 
==ii 
$charii 
||ii 
charii 
.ii  
IsLetterOrDigitii  /
(ii/ 0
thisii0 4
.ii4 5
chii5 7
)ii7 8
)ii8 9
thisii: >
.ii> ?
readii? C
(iiC D
)iiD E
;iiE F
returnjj 
thisjj	 
.jj 
inputjj 
.jj 
	Substringjj 
(jj 
startjj #
,jj# $
thisjj% )
.jj) *
posjj* -
-jj. /
startjj0 5
)jj5 6
;jj6 7
}kk 
privatemm 
Resultmm	 
<mm 
	Expansionmm 
>mm 
parseNormalExpandmm ,
(mm, -
)mm- .
{mm/ 0
varnn 
resnn 	
=nn
 
thisnn 
.nn 
readNamenn 
(nn 
)nn 
;nn 
ifoo 
(oo 
resoo 	
.oo	 

IsErroo
 
)oo 
returnoo 
resoo 
.oo 
Erroo 
;oo  
elsepp 
returnpp 
newpp 
	Expansionpp 
(pp 
respp 
.pp  
Okpp  "
)pp" #
;pp# $
}qq 
privatess 
Resultss	 
<ss 
	Expansionss 
>ss 
parseBracedExpandss ,
(ss, -
)ss- .
{ss/ 0
vartt 
lntt 
=tt	 

thistt 
.tt 
linett 
;tt 
thisuu 
.uu 
expectuu 
(uu 
$charuu 
)uu 
;uu 
stringvv 
leftvv	 
;vv 
varww 
leftResww 
=ww 
thisww 
.ww 
readNameww 
(ww 
)ww 
;ww  
ifxx 
(xx 
leftResxx 
.xx 
IsErrxx 
)xx 
returnxx 
leftResxx #
.xx# $
Errxx$ '
;xx' (
elseyy 
ifyy 	
(yy
 
stringyy 
.yy 
IsNullOrEmptyyy 
(yy  
leftResyy  '
.yy' (
Okyy( *
)yy* +
)yy+ ,
returnyy- 3
newyy4 7
ErrBadSubstitutionyy8 J
(yyJ K
lnyyK M
)yyM N
;yyN O
elsezz 
leftzz 
=zz 
leftReszz 
.zz 
Okzz 
;zz 
var}} 
op}} 
=}}	 

ExpansionOp}} 
.}} 
	OrNothing}}  
;}}  !
if~~ 
(~~ 
this~~ 

.~~
 

tryConsume~~ 
(~~ 
$str~~ 
,~~ 
$str~~ 
)~~  
)~~  !
op 
= 
ExpansionOp 
. 
	OrDefault 
; 
else
── 
if
── 	
(
──
 
this
── 
.
── 

tryConsume
── 
(
── 
$str
── 
,
── 
$str
──  $
)
──$ %
)
──% &
op
││ 
=
││ 
ExpansionOp
││ 
.
││ 

AndReplace
││ 
;
││ 
else
┌┌ 
if
┌┌ 	
(
┌┌
 
this
┌┌ 
.
┌┌ 

tryConsume
┌┌ 
(
┌┌ 
$str
┌┌ 
,
┌┌ 
$str
┌┌  $
)
┌┌$ %
)
┌┌% &
op
┐┐ 
=
┐┐ 
ExpansionOp
┐┐ 
.
┐┐ 
OrError
┐┐ 
;
┐┐ 
else
└└ 
if
└└ 	
(
└└
 
this
└└ 
.
└└ 

tryConsume
└└ 
(
└└ 
$char
└└ 
)
└└ 
)
└└  
return
┘┘ 	
new
┘┘
 
	Expansion
┘┘ 
(
┘┘ 
left
┘┘ 
,
┘┘ 
op
┘┘  
,
┘┘  !
new
┘┘" %
Value
┘┘& +
(
┘┘+ ,
)
┘┘, -
)
┘┘- .
;
┘┘. /
else
┤┤ 
return
┬┬ 	
new
┬┬
 
ErrMissingRBrace
┬┬ 
(
┬┬ 
ln
┬┬ !
)
┬┬! "
;
┬┬" #
if
┴┴ 
(
┴┴ 
this
┴┴ 

.
┴┴
 

tryConsume
┴┴ 
(
┴┴ 
$char
┴┴ 
)
┴┴ 
)
┴┴ 
return
┴┴ "
new
┴┴# &
	Expansion
┴┴' 0
(
┴┴0 1
left
┴┴1 5
,
┴┴5 6
op
┴┴7 9
,
┴┴9 :
new
┴┴; >
Value
┴┴? D
(
┴┴D E
)
┴┴E F
)
┴┴F G
;
┴┴G H
var
▀▀ 
res
▀▀ 	
=
▀▀
 
this
▀▀ 
.
▀▀ !
parseExpansionValue
▀▀ $
(
▀▀$ %
)
▀▀% &
;
▀▀& '
if
▄▄ 
(
▄▄ 
res
▄▄ 	
.
▄▄	 

IsErr
▄▄
 
)
▄▄ 
return
▄▄ 
res
▄▄ 
.
▄▄ 
Err
▄▄ 
;
▄▄  
this
▌▌ 
.
▌▌ 
expect
▌▌ 
(
▌▌ 
$char
▌▌ 
)
▌▌ 
;
▌▌ 
return
▐▐ 
new
▐▐	 
	Expansion
▐▐ 
(
▐▐ 
left
▐▐ 
,
▐▐ 
op
▐▐ 
,
▐▐  
res
▐▐! $
.
▐▐$ %
Ok
▐▐% '
)
▐▐' (
;
▐▐( )
}
░░ 
private
▓▓ 
Result
▓▓	 
<
▓▓ 
	Expansion
▓▓ 
>
▓▓ 
parseExpand
▓▓ &
(
▓▓& '
)
▓▓' (
{
▓▓) *
this
⌠⌠ 
.
⌠⌠ 
expect
⌠⌠ 
(
⌠⌠ 
$char
⌠⌠ 
)
⌠⌠ 
;
⌠⌠ 
if
■■ 
(
■■ 
this
■■ 

.
■■
 
ch
■■ 
==
■■ 
$char
■■ 
)
■■ 
return
■■ 
this
■■ !
.
■■! "
parseBracedExpand
■■" 3
(
■■3 4
)
■■4 5
;
■■5 6
else
∙∙ 
return
∙∙ 
this
∙∙ 
.
∙∙ 
parseNormalExpand
∙∙ $
(
∙∙$ %
)
∙∙% &
;
∙∙& '
}
√√ 
private
≤≤ 
Result
≤≤	 
<
≤≤ 
Value
≤≤ 
>
≤≤ !
parseExpansionValue
≤≤ *
(
≤≤* +
)
≤≤+ ,
{
≤≤- .
var
≥≥ 
ln
≥≥ 
=
≥≥	 

this
≥≥ 
.
≥≥ 
line
≥≥ 
;
≥≥ 
var
   
vals
   

=
   
new
   
Value
   
(
   
)
   
;
   
while
°° 
(
°° 	
this
°°	 
.
°° 
ch
°° 
!=
°° 
$char
°° 
)
°° 
{
°° 
switch
²² 	
(
²²
 
this
²² 
.
²² 
ch
²² 
)
²² 
{
²² 
case
·· 
EOF
··	 
:
·· 
return
÷÷ 
new
÷÷ 
ErrMissingRBrace
÷÷  
(
÷÷  !
ln
÷÷! #
)
÷÷# $
;
÷÷$ %
case
══ 
$char
══	 
:
══ 
var
║║ 
resD
║║	 
=
║║ 
this
║║ 
.
║║ 
readDoubleQuote
║║ $
(
║║$ %
)
║║% &
;
║║& '
if
╒╒ 
(
╒╒ 	
resD
╒╒	 
.
╒╒ 
IsErr
╒╒ 
)
╒╒ 
return
╒╒ 
resD
╒╒  
.
╒╒  !
Err
╒╒! $
;
╒╒$ %
else
ёё 	
vals
ёё
 
.
ёё 
Add
ёё 
(
ёё 
resD
ёё 
.
ёё 
Ok
ёё 
)
ёё 
;
ёё 
break
╓╓ 

;
╓╓
 
case
╔╔ 
$char
╔╔	 
:
╔╔ 
var
╕╕ 
resS
╕╕	 
=
╕╕ 
this
╕╕ 
.
╕╕ 
readSingleQuote
╕╕ $
(
╕╕$ %
)
╕╕% &
;
╕╕& '
if
╖╖ 
(
╖╖ 	
resS
╖╖	 
.
╖╖ 
IsErr
╖╖ 
)
╖╖ 
return
╖╖ 
resS
╖╖  
.
╖╖  !
Err
╖╖! $
;
╖╖$ %
else
╗╗ 	
vals
╗╗
 
.
╗╗ 
Add
╗╗ 
(
╗╗ 
resS
╗╗ 
.
╗╗ 
Ok
╗╗ 
)
╗╗ 
;
╗╗ 
break
╘╘ 

;
╘╘
 
case
╙╙ 
$char
╙╙	 
when
╙╙ 
char
╙╙ 
.
╙╙ 
IsDigit
╙╙ 
(
╙╙ 
this
╙╙ #
.
╙╙# $
peek
╙╙$ (
)
╙╙( )
:
╙╙) *
this
╚╚ 	
.
╚╚	 

read
╚╚
 
(
╚╚ 
)
╚╚ 
;
╚╚ 
this
╛╛ 	
.
╛╛	 

	skipWhile
╛╛
 
(
╛╛ 
c
╛╛ 
=>
╛╛ 
char
╛╛ 
.
╛╛ 
IsDigit
╛╛ %
(
╛╛% &
c
╛╛& '
)
╛╛' (
)
╛╛( )
;
╛╛) *
break
╜╜ 

;
╜╜
 
case
╝╝ 
$char
╝╝	 
when
╝╝ 
this
╝╝ 
.
╝╝ 
peek
╝╝ 
!=
╝╝ 
$char
╝╝ "
&&
╝╝# %
this
╝╝& *
.
╝╝* +
peek
╝╝+ /
!=
╝╝0 2
$char
╝╝3 6
&&
╝╝7 9
!
╝╝: ;
char
╝╝; ?
.
╝╝? @
IsLetter
╝╝@ H
(
╝╝H I
this
╝╝I M
.
╝╝M N
peek
╝╝N R
)
╝╝R S
:
╝╝S T
vals
╞╞ 	
.
╞╞	 

Add
╞╞
 
(
╞╞ 
new
╞╞ 

StrLiteral
╞╞ 
(
╞╞ 
$str
╞╞  
)
╞╞  !
)
╞╞! "
;
╞╞" #
this
╟╟ 	
.
╟╟	 

read
╟╟
 
(
╟╟ 
)
╟╟ 
;
╟╟ 
break
╠╠ 

;
╠╠
 
case
╡╡ 
$char
╡╡	 
:
╡╡ 
var
ЁЁ 
res
ЁЁ	 
=
ЁЁ 
this
ЁЁ 
.
ЁЁ 
parseExpand
ЁЁ 
(
ЁЁ  
)
ЁЁ  !
;
ЁЁ! "
if
╢╢ 
(
╢╢ 	
res
╢╢	 
.
╢╢ 
IsErr
╢╢ 
)
╢╢ 
return
╢╢ 
res
╢╢ 
.
╢╢ 
Err
╢╢ "
;
╢╢" #
else
╣╣ 	
vals
╣╣
 
.
╣╣ 
Add
╣╣ 
(
╣╣ 
res
╣╣ 
.
╣╣ 
Ok
╣╣ 
)
╣╣ 
;
╣╣ 
break
╤╤ 

;
╤╤
 
case
╥╥ 
$char
╥╥	 
:
╥╥ 
this
╦╦ 	
.
╦╦	 

read
╦╦
 
(
╦╦ 
)
╦╦ 
;
╦╦ 
if
╧╧ 
(
╧╧ 	
this
╧╧	 
.
╧╧ 
ch
╧╧ 
!=
╧╧ 
$char
╧╧ 
)
╧╧ 
vals
╨╨ 

.
╨╨
 
Add
╨╨ 
(
╨╨ 
new
╨╨ 

StrLiteral
╨╨ 
(
╨╨ 
this
╨╨ "
.
╨╨" #
ch
╨╨# %
.
╨╨% &
ToString
╨╨& .
(
╨╨. /
)
╨╨/ 0
)
╨╨0 1
)
╨╨1 2
;
╨╨2 3
this
╩╩ 	
.
╩╩	 

read
╩╩
 
(
╩╩ 
)
╩╩ 
;
╩╩ 
break
╪╪ 

;
╪╪
 
default
╫╫ 
:
╫╫ 
if
╬╬ 
(
╬╬ 	
char
╬╬	 
.
╬╬ 
IsWhiteSpace
╬╬ 
(
╬╬ 
this
╬╬ 
.
╬╬  
ch
╬╬  "
)
╬╬" #
)
╬╬# $
{
╬╬% &
vals
©© 

.
©©
 
Add
©© 
(
©© 
new
©© 

StrLiteral
©© 
(
©© 
$str
©© !
)
©©! "
)
©©" #
;
©©# $
this
юю 

.
юю
 
	skipWhile
юю 
(
юю 
c
юю 
=>
юю 
char
юю 
.
юю 
IsWhiteSpace
юю +
(
юю+ ,
c
юю, -
)
юю- .
)
юю. /
;
юю/ 0
}
аа 
else
аа 
{
аа 
vals
бб 

.
бб
 
Add
бб 
(
бб 
new
бб 

StrLiteral
бб 
(
бб 
this
цц 
.
цц 	
	readWhile
цц	 
(
цц 
c
цц 
=>
цц 
!
цц 
	isSpecial
цц "
(
цц" #
c
цц# $
)
цц$ %
&&
цц& (
c
цц) *
!=
цц+ -
$char
цц. 1
&&
цц2 4
!
цц5 6
char
цц6 :
.
цц: ;
IsWhiteSpace
цц; G
(
ццG H
c
ццH I
)
ццI J
)
ццJ K
)
дд 
)
дд 
;
дд 	
}
ее 
break
фф 

;
фф
 
}
гг 
}
хх 
return
лл 
vals
лл	 
;
лл 
}
мм 
private
оо 
Result
оо	 
<
оо 

StrLiteral
оо 
>
оо 
readSingleQuote
оо +
(
оо+ ,
)
оо, -
{
оо. /
var
пп 
ln
пп 
=
пп	 

this
пп 
.
пп 
line
пп 
;
пп 
this
яя 
.
яя 
expect
яя 
(
яя 
$char
яя 
)
яя 
;
яя 
var
рр 
start
рр 
=
рр 
this
рр 
.
рр 
pos
рр 
;
рр 
while
сс 
(
сс 	
this
сс	 
.
сс 
ch
сс 
!=
сс 
$char
сс 
)
сс 
{
сс 
if
тт 
(
тт 
this
тт 
.
тт 
ch
тт 
==
тт 
EOF
тт 
)
тт 
return
тт 
new
тт !
ErrUnclosedQuote
тт" 2
(
тт2 3
ln
тт3 5
)
тт5 6
;
тт6 7
this
уу 
.
уу 
read
уу 
(
уу 
)
уу 
;
уу 
}
жж 
var
вв 
s
вв 
=
вв 	
this
вв
 
.
вв 
input
вв 
.
вв 
	Substring
вв 
(
вв 
start
вв $
,
вв$ %
this
вв& *
.
вв* +
pos
вв+ .
-
вв/ 0
start
вв1 6
)
вв6 7
;
вв7 8
this
ьь 
.
ьь 
expect
ьь 
(
ьь 
$char
ьь 
)
ьь 
;
ьь 
return
ыы 
new
ыы	 

StrLiteral
ыы 
(
ыы 
s
ыы 
)
ыы 
;
ыы 
}
зз 
private
ээ 
Result
ээ	 
<
ээ 
Value
ээ 
>
ээ 
readDoubleQuote
ээ &
(
ээ& '
)
ээ' (
{
ээ) *
var
щщ 
ln
щщ 
=
щщ	 

this
щщ 
.
щщ 
line
щщ 
;
щщ 
this
чч 
.
чч 
expect
чч 
(
чч 
$char
чч 
)
чч 
;
чч 
var
ЮЮ 
buf
ЮЮ 	
=
ЮЮ
 
new
ЮЮ 
StringBuilder
ЮЮ 
(
ЮЮ 
)
ЮЮ 
;
ЮЮ  
var
АА 
vals
АА 

=
АА 
new
АА 
Value
АА 
(
АА 
)
АА 
;
АА 
while
ЦЦ 
(
ЦЦ 	
this
ЦЦ	 
.
ЦЦ 
ch
ЦЦ 
!=
ЦЦ 
$char
ЦЦ 
)
ЦЦ 
{
ЦЦ 
switch
ДД 	
(
ДД
 
this
ДД 
.
ДД 
ch
ДД 
)
ДД 
{
ДД 
case
ЕЕ 
EOF
ЕЕ	 
:
ЕЕ 
return
ФФ 
new
ФФ 
ErrUnclosedQuote
ФФ  
(
ФФ  !
ln
ФФ! #
)
ФФ# $
;
ФФ$ %
case
ХХ 
$char
ХХ	 
when
ХХ 
char
ХХ 
.
ХХ 
IsDigit
ХХ 
(
ХХ 
this
ХХ #
.
ХХ# $
peek
ХХ$ (
)
ХХ( )
:
ХХ) *
this
ИИ 	
.
ИИ	 

read
ИИ
 
(
ИИ 
)
ИИ 
;
ИИ 
this
ЙЙ 	
.
ЙЙ	 

	skipWhile
ЙЙ
 
(
ЙЙ 
c
ЙЙ 
=>
ЙЙ 
char
ЙЙ 
.
ЙЙ 
IsDigit
ЙЙ %
(
ЙЙ% &
c
ЙЙ& '
)
ЙЙ' (
)
ЙЙ( )
;
ЙЙ) *
continue
КК 
;
КК 
case
ЛЛ 
$char
ЛЛ	 
when
ЛЛ 
this
ЛЛ 
.
ЛЛ 
peek
ЛЛ 
!=
ЛЛ 
$char
ЛЛ "
&&
ЛЛ# %
this
ЛЛ& *
.
ЛЛ* +
peek
ЛЛ+ /
!=
ЛЛ0 2
$char
ЛЛ3 6
&&
ЛЛ7 9
!
ЛЛ: ;
char
ЛЛ; ?
.
ЛЛ? @
IsLetter
ЛЛ@ H
(
ЛЛH I
this
ЛЛI M
.
ЛЛM N
peek
ЛЛN R
)
ЛЛR S
:
ЛЛS T
buf
ММ 
.
ММ 	
Append
ММ	 
(
ММ 
$char
ММ 
)
ММ 
;
ММ 
this
НН 	
.
НН	 

read
НН
 
(
НН 
)
НН 
;
НН 
break
ОО 

;
ОО
 
case
ПП 
$char
ПП	 
:
ПП 
var
ЯЯ 
res
ЯЯ	 
=
ЯЯ 
this
ЯЯ 
.
ЯЯ 
parseExpand
ЯЯ 
(
ЯЯ  
)
ЯЯ  !
;
ЯЯ! "
if
РР 
(
РР 	
res
РР	 
.
РР 
IsErr
РР 
)
РР 
return
РР 
res
РР 
.
РР 
Err
РР "
;
РР" #
if
СС 
(
СС 	
buf
СС	 
.
СС 
Length
СС 
!=
СС 
$num
СС 
)
СС 
{
СС 
vals
ТТ 

.
ТТ
 
Add
ТТ 
(
ТТ 
new
ТТ 

StrLiteral
ТТ 
(
ТТ 
buf
ТТ !
.
ТТ! "
ToString
ТТ" *
(
ТТ* +
)
ТТ+ ,
)
ТТ, -
)
ТТ- .
;
ТТ. /
buf
УУ 	
.
УУ	 

Clear
УУ
 
(
УУ 
)
УУ 
;
УУ 
}
ЖЖ 
vals
ВВ 	
.
ВВ	 

Add
ВВ
 
(
ВВ 
res
ВВ 
.
ВВ 
Ok
ВВ 
)
ВВ 
;
ВВ 
continue
ЬЬ 
;
ЬЬ 
case
ЫЫ 
$char
ЫЫ	 
when
ЫЫ 
this
ЫЫ 
.
ЫЫ 
peek
ЫЫ 
==
ЫЫ 
$char
ЫЫ  $
:
ЫЫ$ %
this
ЗЗ 	
.
ЗЗ	 

read
ЗЗ
 
(
ЗЗ 
)
ЗЗ 
;
ЗЗ 
break
ШШ 

;
ШШ
 
case
ЭЭ 
$char
ЭЭ	 
:
ЭЭ 
this
ЩЩ 	
.
ЩЩ	 

read
ЩЩ
 
(
ЩЩ 
)
ЩЩ 
;
ЩЩ 
buf
ЧЧ 
.
ЧЧ 	
Append
ЧЧ	 
(
ЧЧ 
escaped
ЧЧ 
(
ЧЧ 
this
ЧЧ 
.
ЧЧ 
ch
ЧЧ 
)
ЧЧ  
)
ЧЧ  !
;
ЧЧ! "
break
ЪЪ 

;
ЪЪ
 
default
── 
:
── 
buf
││ 
.
││ 	
Append
││	 
(
││ 
this
││ 
.
││ 
ch
││ 
)
││ 
;
││ 
break
┌┌ 

;
┌┌
 
}
┐┐ 
this
┘┘ 
.
┘┘ 
read
┘┘ 
(
┘┘ 
)
┘┘ 
;
┘┘ 
}
├├ 
this
┬┬ 
.
┬┬ 
expect
┬┬ 
(
┬┬ 
$char
┬┬ 
)
┬┬ 
;
┬┬ 
if
┼┼ 
(
┼┼ 
buf
┼┼ 	
.
┼┼	 

Length
┼┼
 
!=
┼┼ 
$num
┼┼ 
)
┼┼ 
vals
┼┼ 
.
┼┼ 
Add
┼┼ 
(
┼┼  
new
┼┼  #

StrLiteral
┼┼$ .
(
┼┼. /
buf
┼┼/ 2
.
┼┼2 3
ToString
┼┼3 ;
(
┼┼; <
)
┼┼< =
)
┼┼= >
)
┼┼> ?
;
┼┼? @
return
▀▀ 
vals
▀▀	 
;
▀▀ 
}
▄▄ 
private
▌▌ 
Result
▌▌	 
<
▌▌ 
Value
▌▌ 
>
▌▌ 

parseValue
▌▌ !
(
▌▌! "
)
▌▌" #
{
▌▌$ %
var
░░ 
vals
░░ 

=
░░ 
new
░░ 
Value
░░ 
(
░░ 
)
░░ 
;
░░ 
while
▓▓ 
(
▓▓ 	
this
▓▓	 
.
▓▓ 
ch
▓▓ 
!=
▓▓ 
EOF
▓▓ 
&&
▓▓ 
!
▓▓ 
char
▓▓  
.
▓▓  !
IsWhiteSpace
▓▓! -
(
▓▓- .
this
▓▓. 2
.
▓▓2 3
ch
▓▓3 5
)
▓▓5 6
)
▓▓6 7
{
▓▓8 9
switch
⌠⌠ 	
(
⌠⌠
 
this
⌠⌠ 
.
⌠⌠ 
ch
⌠⌠ 
)
⌠⌠ 
{
⌠⌠ 
case
■■ 
$char
■■	 
:
■■ 
var
∙∙ 
resD
∙∙	 
=
∙∙ 
this
∙∙ 
.
∙∙ 
readDoubleQuote
∙∙ $
(
∙∙$ %
)
∙∙% &
;
∙∙& '
if
√√ 
(
√√ 	
resD
√√	 
.
√√ 
IsErr
√√ 
)
√√ 
return
√√ 
resD
√√  
.
√√  !
Err
√√! $
;
√√$ %
else
≈≈ 	
vals
≈≈
 
.
≈≈ 
Add
≈≈ 
(
≈≈ 
resD
≈≈ 
.
≈≈ 
Ok
≈≈ 
)
≈≈ 
;
≈≈ 
break
≤≤ 

;
≤≤
 
case
≥≥ 
$char
≥≥	 
:
≥≥ 
var
   
resS
  	 
=
   
this
   
.
   
readSingleQuote
   $
(
  $ %
)
  % &
;
  & '
if
⌡⌡ 
(
⌡⌡ 	
resS
⌡⌡	 
.
⌡⌡ 
IsErr
⌡⌡ 
)
⌡⌡ 
return
⌡⌡ 
resS
⌡⌡  
.
⌡⌡  !
Err
⌡⌡! $
;
⌡⌡$ %
else
°° 	
vals
°°
 
.
°° 
Add
°° 
(
°° 
resS
°° 
.
°° 
Ok
°° 
)
°° 
;
°° 
break
²² 

;
²²
 
case
·· 
$char
··	 
when
·· 
char
·· 
.
·· 
IsDigit
·· 
(
·· 
this
·· #
.
··# $
peek
··$ (
)
··( )
:
··) *
this
÷÷ 	
.
÷÷	 

read
÷÷
 
(
÷÷ 
)
÷÷ 
;
÷÷ 
this
══ 	
.
══	 

	skipWhile
══
 
(
══ 
c
══ 
=>
══ 
char
══ 
.
══ 
IsDigit
══ %
(
══% &
c
══& '
)
══' (
)
══( )
;
══) *
break
║║ 

;
║║
 
case
╒╒ 
$char
╒╒	 
when
╒╒ 
this
╒╒ 
.
╒╒ 
peek
╒╒ 
!=
╒╒ 
$char
╒╒ "
&&
╒╒# %
this
╒╒& *
.
╒╒* +
peek
╒╒+ /
!=
╒╒0 2
$char
╒╒3 6
&&
╒╒7 9
!
╒╒: ;
char
╒╒; ?
.
╒╒? @
IsLetter
╒╒@ H
(
╒╒H I
this
╒╒I M
.
╒╒M N
peek
╒╒N R
)
╒╒R S
:
╒╒S T
vals
ёё 	
.
ёё	 

Add
ёё
 
(
ёё 
new
ёё 

StrLiteral
ёё 
(
ёё 
$str
ёё  
)
ёё  !
)
ёё! "
;
ёё" #
this
╓╓ 	
.
╓╓	 

read
╓╓
 
(
╓╓ 
)
╓╓ 
;
╓╓ 
break
╔╔ 

;
╔╔
 
case
╕╕ 
$char
╕╕	 
:
╕╕ 
var
╖╖ 
res
╖╖	 
=
╖╖ 
this
╖╖ 
.
╖╖ 
parseExpand
╖╖ 
(
╖╖  
)
╖╖  !
;
╖╖! "
if
╗╗ 
(
╗╗ 	
res
╗╗	 
.
╗╗ 
IsErr
╗╗ 
)
╗╗ 
return
╗╗ 
res
╗╗ 
.
╗╗ 
Err
╗╗ "
;
╗╗" #
else
╘╘ 	
vals
╘╘
 
.
╘╘ 
Add
╘╘ 
(
╘╘ 
res
╘╘ 
.
╘╘ 
Ok
╘╘ 
)
╘╘ 
;
╘╘ 
break
╙╙ 

;
╙╙
 
case
╚╚ 
$char
╚╚	 
:
╚╚ 
if
╛╛ 
(
╛╛ 	
this
╛╛	 
.
╛╛ 
peek
╛╛ 
==
╛╛ 
$char
╛╛ 
)
╛╛ 
{
╛╛ 
this
╜╜ 

.
╜╜
 
read
╜╜ 
(
╜╜ 
)
╜╜ 
;
╜╜ 
this
╝╝ 

.
╝╝
 
read
╝╝ 
(
╝╝ 
)
╝╝ 
;
╝╝ 
if
╞╞ 
(
╞╞	 

vals
╞╞
 
.
╞╞ 
Count
╞╞ 
==
╞╞ 
$num
╞╞ 
)
╞╞ 
{
╞╞ 
this
╟╟ 
.
╟╟ 
	skipSpace
╟╟ 
(
╟╟ 
)
╟╟ 
;
╟╟ 
continue
╠╠ 
;
╠╠ 
}
╡╡ 
}
ЁЁ 
else
ЁЁ 
{
ЁЁ 
this
╢╢ 

.
╢╢
 
read
╢╢ 
(
╢╢ 
)
╢╢ 
;
╢╢ 
vals
╣╣ 

.
╣╣
 
Add
╣╣ 
(
╣╣ 
new
╣╣ 

StrLiteral
╣╣ 
(
╣╣ 
this
╣╣ "
.
╣╣" #
ch
╣╣# %
.
╣╣% &
ToString
╣╣& .
(
╣╣. /
)
╣╣/ 0
)
╣╣0 1
)
╣╣1 2
;
╣╣2 3
}
╤╤ 
break
╥╥ 

;
╥╥
 
default
╦╦ 
:
╦╦ 
vals
╧╧ 	
.
╧╧	 

Add
╧╧
 
(
╧╧ 
new
╧╧ 

StrLiteral
╧╧ 
(
╧╧ 
this
╨╨ 	
.
╨╨	 

	readWhile
╨╨
 
(
╨╨ 
c
╨╨ 
=>
╨╨ 
!
╨╨ 
char
╨╨ 
.
╨╨ 
IsWhiteSpace
╨╨ +
(
╨╨+ ,
c
╨╨, -
)
╨╨- .
&&
╨╨/ 1
!
╨╨2 3
	isSpecial
╨╨3 <
(
╨╨< =
c
╨╨= >
)
╨╨> ?
)
╨╨? @
)
╩╩ 
)
╩╩ 
;
╩╩ 
break
╪╪ 

;
╪╪
 
}
╫╫ 
}
╬╬ 
return
©© 
vals
©©	 
;
©© 
}
юю 
private
бб 
Result
бб	 
<
бб 
Entry
бб 
>
бб 

parseEntry
бб !
(
бб! "
)
бб" #
{
бб$ %
var
цц 
ln
цц 
=
цц	 

this
цц 
.
цц 
line
цц 
;
цц 
this
дд 
.
дд 

tryConsume
дд 
(
дд 
$str
дд 
,
дд 
$str
дд '
)
дд' (
;
дд( )
this
ее 
.
ее 
	skipSpace
ее 
(
ее 
)
ее 
;
ее 
var
фф 
name
фф 

=
фф 
this
фф 
.
фф 
readName
фф 
(
фф 
)
фф 
;
фф 
if
гг 
(
гг 
name
гг 

.
гг
 
IsErr
гг 
)
гг 
return
гг 
name
гг 
.
гг 
Err
гг !
;
гг! "
this
ии 
.
ии 
	skipSpace
ии 
(
ии 
)
ии 
;
ии 
if
кк 
(
кк 
this
кк 

.
кк
 
ch
кк 
!=
кк 
$char
кк 
)
кк 
return
кк 
new
кк  
ErrMissingEquals
кк! 1
(
кк1 2
ln
кк2 4
)
кк4 5
;
кк5 6
this
лл 
.
лл 
read
лл 
(
лл 
)
лл 
;
лл 
this
мм 
.
мм 
	skipSpace
мм 
(
мм 
)
мм 
;
мм 
if
оо 
(
оо 
this
оо 

.
оо
 
ch
оо 
==
оо 
$char
оо 
||
оо 
this
оо 
.
оо 
ch
оо  
==
оо! #
EOF
оо$ '
)
оо' (
{
оо) *
return
пп 	
new
пп
 
Entry
пп 
(
пп 
name
пп 
.
пп 
Ok
пп 
,
пп 
new
пп  
Value
пп! &
(
пп& '
)
пп' (
)
пп( )
;
пп) *
}
яя 
var
сс 
res
сс 	
=
сс
 
this
сс 
.
сс 

parseValue
сс 
(
сс 
)
сс 
;
сс 
if
тт 
(
тт 
res
тт 	
.
тт	 

IsErr
тт
 
)
тт 
return
тт 
res
тт 
.
тт 
Err
тт 
;
тт  
this
уу 
.
уу 
	skipSpace
уу 
(
уу 
)
уу 
;
уу 
if
жж 
(
жж 
this
жж 

.
жж
 
ch
жж 
!=
жж 
$char
жж 
&&
жж 
this
жж 
.
жж 
ch
жж  
!=
жж! #
$char
жж$ '
&&
жж( *
this
жж+ /
.
жж/ 0
ch
жж0 2
!=
жж3 5
EOF
жж6 9
)
жж9 :
{
жж; <
return
вв 	
new
вв
 
ErrMissingNewline
вв 
(
вв  
this
вв  $
.
вв$ %
line
вв% )
)
вв) *
;
вв* +
}
ьь 
return
ыы 
new
ыы	 
Entry
ыы 
(
ыы 
name
ыы 
.
ыы 
Ok
ыы 
,
ыы 
res
ыы 
.
ыы  
Ok
ыы  "
)
ыы" #
;
ыы# $
}
зз 
public
ээ 
IEnumerator
ээ 
<
ээ 
Result
ээ 
<
ээ 
Entry
ээ  
>
ээ  !
>
ээ! "
GetEnumerator
ээ# 0
(
ээ0 1
)
ээ1 2
{
ээ3 4
while
щщ 
(
щщ 	
this
щщ	 
.
щщ 
ch
щщ 
!=
щщ 
EOF
щщ 
)
щщ 
{
щщ 
this
чч 
.
чч 
	skipWhile
чч 
(
чч 
c
чч 
=>
чч 
char
чч 
.
чч 
IsWhiteSpace
чч (
(
чч( )
c
чч) *
)
чч* +
)
чч+ ,
;
чч, -
if
ъъ 
(
ъъ 
this
ъъ 
.
ъъ 
ch
ъъ 
==
ъъ 
$char
ъъ 
)
ъъ 
{
ъъ 
this
ЮЮ 
.
ЮЮ 	
skipLine
ЮЮ	 
(
ЮЮ 
)
ЮЮ 
;
ЮЮ 
continue
АА 
;
АА 
}
ББ 
if
ЦЦ 
(
ЦЦ 
this
ЦЦ 
.
ЦЦ 
ch
ЦЦ 
==
ЦЦ 
EOF
ЦЦ 
)
ЦЦ 
break
ЦЦ 
;
ЦЦ 
var
ДД 
res
ДД 

=
ДД 
this
ДД 
.
ДД 

parseEntry
ДД 
(
ДД 
)
ДД 
;
ДД 
if
ЕЕ 
(
ЕЕ 
res
ЕЕ 

.
ЕЕ
 
IsErr
ЕЕ 
)
ЕЕ 
this
ЕЕ 
.
ЕЕ 
skipLine
ЕЕ 
(
ЕЕ  
)
ЕЕ  !
;
ЕЕ! "
yield
ФФ 
return
ФФ	 
res
ФФ 
;
ФФ 
}
ГГ 
}
ХХ 
IEnumerator
ЙЙ 
IEnumerable
ЙЙ 
.
ЙЙ 
GetEnumerator
ЙЙ &
(
ЙЙ& '
)
ЙЙ' (
=>
ЙЙ) +
GetEnumerator
ЙЙ, 9
(
ЙЙ9 :
)
ЙЙ: ;
;
ЙЙ; <
}КК ⌡
,D:\home\projects\ps-dotenv\Parsing\Result.cs
	namespace 	
Dotenv
 
. 
Parsing 
; 
public 
class 
Result 
< 
T 
> 
{ 
public 
T 	
?	 

Ok 
{ 
get 
; 
set 
; 
} 
public 

ParseError 
? 
Err 
{ 
get 
; 
set "
;" #
}$ %
public 
bool 
IsErr 
=> 
this 
. 
Err 
is !
not" %
null& *
;* +
public 
Result 
( 
T 
ok 
) 
=> 
( 
this 
. 
Ok  
,  !
this" &
.& '
Err' *
)* +
=, -
(. /
ok/ 1
,1 2
null3 7
)7 8
;8 9
public		 
Result		 
(		 

ParseError		 
err		 
)		 
=>		 !
(		" #
this		# '
.		' (
Ok		( *
,		* +
this		, 0
.		0 1
Err		1 4
)		4 5
=		6 7
(		8 9
default		9 @
(		@ A
T		A B
)		B C
,		C D
err		E H
)		H I
;		I J
public 
static 
implicit 
operator  
Result! '
<' (
T( )
>) *
(* +
T+ ,
ok- /
)/ 0
=>1 3
new4 7
Result8 >
<> ?
T? @
>@ A
(A B
okB D
)D E
;E F
public 
static 
implicit 
operator  
Result! '
<' (
T( )
>) *
(* +

ParseError+ 5
e6 7
)7 8
=>9 ;
new< ?
Result@ F
<F G
TG H
>H I
(I J
eJ K
)K L
;L M
} ║@
)D:\home\projects\ps-dotenv\Parsing\str.cs
	namespace 	
Dotenv
 
. 
Parsing 
; 
internal 
enum	 
ExpansionOp 
{ 
	OrNothing 

,
 
	OrDefault 

,
 
OrError 
, 	

AndReplace		 
,		 
}

 
	interface 	
Expr
 
{ 
string 
ExpandValue 
( 
) 
; 
} 
internal 
readonly	 
struct 

StrLiteral #
:# $
Expr% )
{* +
private 
readonly	 
string 
val 
{ 
get "
;" #
init$ (
;( )
}* +
public 

StrLiteral 
( 
string 
s 
) 
=> 
this  $
.$ %
val% (
=) *
s+ ,
;, -
public 
static 
implicit 
operator  

StrLiteral! +
(+ ,
string, 2
s3 4
)4 5
=>6 8
new9 <

StrLiteral= G
(G H
sH I
)I J
;J K
public 
string 
ExpandValue 
( 
) 
=> 
this  $
.$ %
val% (
;( )
public 
override 
string 
ToString  
(  !
)! "
=># %
this& *
.* +
val+ .
;. /
} 
internal 
class	 
	Expansion 
: 
Expr 
{  
internal 	
	Expansion
 
( 
string 
left 
,  
ExpansionOp! ,
op- /
,/ 0
Value1 6
right7 <
)< =
{> ?
this 
. 
left 
= 
left 
; 
this 
. 
right 
= 
right 
; 
this 
. 
op 	
=
 
op 
; 
}   
internal!! 	
	Expansion!!
 
(!! 
string!! 
name!! 
)!!  
{!!! "
this"" 
."" 
left"" 
="" 
name"" 
;"" 
this## 
.## 
right## 
=## 
new## 
Value## 
(## 
)## 
;## 
this$$ 
.$$ 
op$$ 	
=$$
 
ExpansionOp$$ 
.$$ 
	OrNothing$$ !
;$$! "
}%% 
private'' 
readonly''	 
string'' 
left'' 
;'' 
private(( 
readonly((	 
ExpansionOp(( 
op((  
;((  !
private)) 
readonly))	 
Value)) 
right)) 
;)) 
public++ 
string++ 
ExpandValue++ 
(++ 
)++ 
{++ 
var,, 
s,, 
=,, 	
System,,
 
.,, 
Environment,, 
.,, "
GetEnvironmentVariable,, 3
(,,3 4
this,,4 8
.,,8 9
left,,9 =
??,,> @
$str,,A C
),,C D
;,,D E
switch-- 
(--	 

this--
 
.-- 
op-- 
)-- 
{-- 
case.. 
ExpansionOp.. 
... 
	OrNothing.. 
:.. 
return// 

s// 
;// 
case00 
ExpansionOp00 
.00 
	OrDefault00 
:00 
if11 
(11 
string11 
.11 
IsNullOrEmpty11 
(11 
s11 
)11 
)11  
return11! '
this11( ,
.11, -
right11- 2
.112 3
ExpandValue113 >
(11> ?
)11? @
;11@ A
else22 
return22	 
s22 
;22 
case33 
ExpansionOp33 
.33 

AndReplace33 
:33 
if44 
(44 
string44 
.44 
IsNullOrEmpty44 
(44 
s44 
)44 
)44  
return44! '
$str44( *
;44* +
else55 
return55	 
this55 
.55 
right55 
.55 
ExpandValue55 &
(55& '
)55' (
;55( )
case66 
ExpansionOp66 
.66 
OrError66 
:66 
if77 
(77 
string77 
.77 
IsNullOrEmpty77 
(77 
s77 
)77 
)77  
throw88 

new88 
VarUnsetException88  
(88  !
this88! %
.88% &
left88& *
??88+ -
$str88. 0
,880 1
this882 6
.886 7
right887 <
?88< =
.88= >
ExpandValue88> I
(88I J
)88J K
??88L N
$str88O h
)88h i
;88i j
else99 
return:: 
s:: 
;:: 
default;; 

:;;
 
throw<< 	
new<<
 
AssertionException<<  
(<<  !
$str<<! 6
)<<6 7
;<<7 8
}== 
}>> 
}?? 
internalAA 
classAA	 
ValueAA 
:AA 
ExprAA 
{AA 
privateBB 
ListBB	 
<BB 
ExprBB 
>BB 
	fragmentsBB 
=BB 
newBB  #
(BB# $
)BB$ %
;BB% &
publicCC 
intCC 
CountCC 
=>CC 
thisCC 
.CC 
	fragmentsCC #
.CC# $
CountCC$ )
;CC) *
internalEE 	
ValueEE
 
(EE 
)EE 
{EE 
}EE 
publicGG 
voidGG 
AddGG 
(GG 

StrLiteralGG 
sGG 
)GG 
=>GG !
thisGG" &
.GG& '
	fragmentsGG' 0
.GG0 1
AddGG1 4
(GG4 5
sGG5 6
)GG6 7
;GG7 8
publicHH 
voidHH 
AddHH 
(HH 
	ExpansionHH 
eHH 
)HH 
=>HH  
thisHH! %
.HH% &
	fragmentsHH& /
.HH/ 0
AddHH0 3
(HH3 4
eHH4 5
)HH5 6
;HH6 7
publicII 
voidII 
AddII 
(II 
ValueII 
vII 
)II 
=>II 
thisII !
.II! "
	fragmentsII" +
.II+ ,
AddII, /
(II/ 0
vII0 1
)II1 2
;II2 3
publicKK 
stringKK 
ExpandValueKK 
(KK 
)KK 
{KK 
ifLL 
(LL 
thisLL 

.LL
 
	fragmentsLL 
isLL 
nullLL 
||LL 
thisLL  $
.LL$ %
	fragmentsLL% .
.LL. /
CountLL/ 4
==LL5 7
$numLL8 9
)LL9 :
returnLL; A
$strLLB D
;LLD E
varNN 
bufNN 	
=NN
 
newNN 
StringBuilderNN 
(NN 
)NN 
;NN  
foreachOO 	
(OO
 
varOO 
xOO 
inOO 
thisOO 
.OO 
	fragmentsOO "
)OO" #
bufOO$ '
.OO' (
AppendOO( .
(OO. /
xOO/ 0
.OO0 1
ExpandValueOO1 <
(OO< =
)OO= >
)OO> ?
;OO? @
returnPP 
bufPP	 
.PP 
ToStringPP 
(PP 
)PP 
;PP 
}QQ 
}RR 